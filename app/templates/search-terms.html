{% extends 'base.html' %}
{% block title %}Unique Terms · Historical Document Reader{% endblock %}

{% block content %}
<div class="container search-terms-page">
    <!-- Added explicit control help so Search Terms matches network-analysis tooltip richness. -->
    <header class="search-terms__header">
        <h1>Unique terms explorer</h1>
        <p>Pick a field, choose words or phrases, then click a term to run a database search.</p>
        <ol class="search-terms__steps">
            <li>Choose a field</li>
            <li>Select words or phrases</li>
            <li>Explore and launch search</li>
        </ol>
    </header>

    <section class="search-terms__panel">
        <h2>Field</h2>
        <div id="fieldQuickPicks" class="search-terms__chips" aria-label="Suggested fields" data-help="Quick-pick chips for frequently used fields."></div>
        <div class="search-terms__filters">
            <label for="fieldSelect">All fields</label>
            <select id="fieldSelect" data-help="Choose which field to analyze for unique words and phrases.">
                <option value="" disabled selected>Select a field</option>
                {% for field in field_structure|dictsort %}
                    {% if field[0] not in unique_fields %}
                    <option value="{{ field[0] }}">{{ field[0] }}</option>
                    {% endif %}
                {% endfor %}
            </select>
        </div>
    </section>

    <section class="search-terms__panel">
        <h2>Explore</h2>
        <div class="search-terms__controls">
            <label for="searchInput">Filter terms</label>
            <input type="text" id="searchInput" placeholder="Type to filter terms..." aria-label="Filter terms" data-help="Filter currently loaded terms by substring match.">
            <button id="clearSearchButton" class="button--secondary" type="button" aria-label="Clear filter" data-help="Clear the term filter input.">Clear</button>
        </div>

        <div class="search-terms__tabs" role="tablist" aria-label="Term type">
            <button id="wordsTab" class="search-terms__tab is-active" type="button" data-type="word" role="tab" aria-selected="true" data-help="Show unique single-word terms for the selected field.">Words</button>
            <button id="phrasesTab" class="search-terms__tab" type="button" data-type="phrase" role="tab" aria-selected="false" data-help="Show unique multi-word phrases for the selected field.">Phrases</button>
        </div>

        <div class="search-terms__meta">
            <p>Field: <span id="activeField">None</span></p>
            <p>Unique words: <span id="uniqueWords">0</span></p>
            <p>Unique phrases: <span id="uniquePhrases">0</span></p>
            <p>Total records: <span id="totalRecords">0</span></p>
        </div>
        <p id="resultsSummary" class="search-terms__summary">Select a field to load data.</p>

        <div id="loadingIndicator" class="loading-indicator" hidden>
            <div class="spinner"></div>
            <p>Loading data…</p>
        </div>
        <div id="noDataMessage" class="search-terms__empty" hidden></div>

        <div class="search-terms__table-wrapper">
            <table id="termsTable" class="search-terms__table">
                <thead>
                    <tr>
                        <th>Term</th>
                        <th>Count</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="termsTableBody"></tbody>
            </table>
        </div>

        <div class="pagination-controls">
            <button id="prevPage" disabled data-help="Load the previous page of unique terms.">Previous</button>
            <span>Page <span id="currentPage">1</span></span>
            <button id="nextPage" data-help="Load the next page of unique terms.">Next</button>
        </div>
    </section>

    <section class="search-terms__panel">
        <h2>Cross-tab Analysis</h2>
        <p>Given an anchor term in the selected field, find words that are disproportionately likely to appear with it.</p>
        <div class="search-terms__crosstab-controls">
            <label for="anchorInput">Anchor term</label>
            <input id="anchorInput" type="text" placeholder="Example: relief" data-help="Enter the anchor term used for co-occurrence comparison.">
            <label for="minDocFreqInput">Min global docs</label>
            <input id="minDocFreqInput" type="number" min="1" value="5" data-help="Minimum global document frequency for candidate terms.">
            <label for="minCoDocsInput">Min co-docs</label>
            <input id="minCoDocsInput" type="number" min="1" value="3" data-help="Minimum number of documents containing both anchor and candidate term.">
            <label for="crossTabLimitInput">Rows</label>
            <input id="crossTabLimitInput" type="number" min="1" max="100" value="25" data-help="Maximum number of cross-tab rows to return.">
            <button id="runCrossTabButton" type="button" data-help="Run cross-tab lift analysis for the current anchor term.">Run analysis</button>
        </div>

        <div id="crossTabLoading" class="loading-indicator" hidden>
            <div class="spinner"></div>
            <p>Computing cross-tab...</p>
        </div>

        <p id="crossTabSummary" class="search-terms__summary">Enter an anchor term and run analysis.</p>
        <div class="search-terms__table-wrapper">
            <table id="crossTabTable" class="search-terms__table">
                <thead>
                    <tr>
                        <th data-help="Candidate word that appears disproportionately with the anchor term.">Term</th>
                        <th data-help="Relative over-representation. Values above 1 mean this term is more likely in anchor documents than elsewhere.">Lift</th>
                        <th data-help="Number of documents containing both this term and the anchor term.">With Anchor</th>
                        <th data-help="Number of documents containing this term anywhere in the selected field.">Global Docs</th>
                        <th data-help="Use Search to pivot into database search, or Copy to reuse the term.">Actions</th>
                    </tr>
                </thead>
                <tbody id="crossTabBody"></tbody>
            </table>
        </div>
    </section>

    <template id="termRowTemplate">
        <tr>
            <td class="search-terms__term"></td>
            <td class="search-terms__count"></td>
            <td class="search-terms__actions"></td>
        </tr>
    </template>
</div>
{% endblock %}

{% block scripts %}
{{ super() }}
<script>
(function() {
    // Keep request/response contracts unchanged while improving interaction flow.
    let currentPage = 1;
    const perPage = 100;
    let selectedField = '';
    let searchQuery = '';
    let activeType = 'word';
    let latestPayload = null;
    let searchDebounceId = null;

    const fieldSelect = document.getElementById('fieldSelect');
    const quickPicks = document.getElementById('fieldQuickPicks');
    const searchInput = document.getElementById('searchInput');
    const clearSearchButton = document.getElementById('clearSearchButton');
    const termsTableBody = document.getElementById('termsTableBody');
    const resultsSummary = document.getElementById('resultsSummary');
    const activeField = document.getElementById('activeField');
    const loadingIndicator = document.getElementById('loadingIndicator');
    const noDataMessage = document.getElementById('noDataMessage');
    const wordsTab = document.getElementById('wordsTab');
    const phrasesTab = document.getElementById('phrasesTab');
    const anchorInput = document.getElementById('anchorInput');
    const runCrossTabButton = document.getElementById('runCrossTabButton');
    const crossTabBody = document.getElementById('crossTabBody');
    const crossTabSummary = document.getElementById('crossTabSummary');
    const crossTabLoading = document.getElementById('crossTabLoading');
    const minDocFreqInput = document.getElementById('minDocFreqInput');
    const minCoDocsInput = document.getElementById('minCoDocsInput');
    const crossTabLimitInput = document.getElementById('crossTabLimitInput');

    function toggleLoading(active) {
        if (!loadingIndicator) return;
        loadingIndicator.hidden = !active;
    }

    function showEmptyState(message) {
        if (!noDataMessage) return;
        noDataMessage.textContent = message || '';
        noDataMessage.hidden = !message;
    }

    function updateMeta(data) {
        document.getElementById('uniqueWords').textContent = data.unique_words;
        document.getElementById('uniquePhrases').textContent = data.unique_phrases;
        document.getElementById('totalRecords').textContent = data.total_records;
        activeField.textContent = selectedField || 'None';
    }

    function updatePagination(page, hasMore) {
        document.getElementById('currentPage').textContent = page;
        document.getElementById('prevPage').disabled = page === 1;
        document.getElementById('nextPage').disabled = !hasMore;
    }

    function toggleCrossTabLoading(active) {
        if (!crossTabLoading) return;
        crossTabLoading.hidden = !active;
    }

    function updateTabs() {
        const tabs = [wordsTab, phrasesTab];
        tabs.forEach(tab => {
            const isActive = tab.dataset.type === activeType;
            tab.classList.toggle('is-active', isActive);
            tab.setAttribute('aria-selected', String(isActive));
        });
    }

    function normalizeRows(payload) {
        if (!payload) return [];
        const sourceRows = activeType === 'word' ? (payload.words || []) : (payload.phrases || []);
        return sourceRows.map(row => ({
            term: activeType === 'word' ? row.word : row.phrase,
            count: row.count
        }));
    }

    function searchUrlForTerm(term) {
        const params = new URLSearchParams({
            prefill_field: selectedField,
            prefill_term: term
        });
        return `/search?${params.toString()}`;
    }

    function renderRows(payload) {
        const rows = normalizeRows(payload);
        const maxCount = Math.max(...rows.map(row => row.count), 1);

        if (!termsTableBody) return;
        termsTableBody.innerHTML = '';

        rows.forEach(row => {
            const tr = document.createElement('tr');

            const termCell = document.createElement('td');
            termCell.className = 'search-terms__term';
            termCell.textContent = row.term;

            const countCell = document.createElement('td');
            countCell.className = 'search-terms__count';
            const barWidth = Math.max(4, Math.round((row.count / maxCount) * 100));
            countCell.innerHTML = `
                <div class="search-terms__count-wrap">
                    <span>${row.count}</span>
                    <div class="search-terms__count-bar"><span style="width:${barWidth}%"></span></div>
                </div>
            `;

            const actionsCell = document.createElement('td');
            actionsCell.className = 'search-terms__actions';
            // Keep actions explicit for fast pivoting into database search and clipboard workflows.
            actionsCell.innerHTML = `
                <a class="search-terms__action-link" href="${searchUrlForTerm(row.term)}" data-help="Open Search with this term prefilled as field + term.">Search</a>
                <button class="search-terms__action-button" type="button" data-copy-term="${row.term}" data-help="Copy this term to the clipboard.">Copy</button>
            `;

            tr.appendChild(termCell);
            tr.appendChild(countCell);
            tr.appendChild(actionsCell);
            termsTableBody.appendChild(tr);
        });

        const hasRows = rows.length > 0;
        if (hasRows) {
            resultsSummary.textContent = `Showing ${rows.length} ${activeType === 'word' ? 'words' : 'phrases'} on page ${currentPage}.`;
        } else {
            resultsSummary.textContent = `No ${activeType === 'word' ? 'words' : 'phrases'} match the current filter.`;
        }
    }

    function fetchData(page) {
        if (!selectedField) {
            termsTableBody.innerHTML = '';
            updateMeta({ unique_words: 0, unique_phrases: 0, total_records: 0 });
            updatePagination(1, false);
            showEmptyState('Select a field to load unique terms.');
            return;
        }

        toggleLoading(true);
        showEmptyState('');

        const params = new URLSearchParams({
            field: selectedField,
            page: String(page),
            per_page: String(perPage),
            query: searchQuery
        });

        fetch(`{{ url_for('search_terms') }}?${params.toString()}`, {
            headers: {
                'X-Requested-With': 'XMLHttpRequest'
            }
        })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                latestPayload = data;
                if (data.words.length === 0 && data.phrases.length === 0) {
                    showEmptyState('No data available for the selected field or search query.');
                }
                // Seed cross-tab with a sensible default anchor for quicker analysis.
                if (anchorInput && !anchorInput.value && data.words && data.words.length) {
                    anchorInput.value = data.words[0].word;
                }
                renderRows(data);
                updateMeta(data);
                const activeRows = activeType === 'word' ? data.words : data.phrases;
                const hasMore = activeRows.length === perPage;
                updatePagination(page, hasMore);
            })
            .catch(error => {
                alert('Error fetching data: ' + error.message);
            })
            .finally(() => {
                toggleLoading(false);
            });
    }

    function setField(fieldName) {
        if (!fieldName) return;
        selectedField = fieldName;
        if (fieldSelect) {
            fieldSelect.value = fieldName;
        }
        currentPage = 1;
        fetchData(currentPage);
        updateQuickPickState();
    }

    function updateQuickPickState() {
        if (!quickPicks) return;
        const buttons = quickPicks.querySelectorAll('button');
        buttons.forEach(button => {
            const isActive = button.dataset.field === selectedField;
            button.classList.toggle('is-active', isActive);
            button.setAttribute('aria-pressed', String(isActive));
        });
    }

    function buildQuickPicks(availableFields) {
        if (!quickPicks) return;
        quickPicks.innerHTML = '';
        const preferredOrder = ['ocr_text', 'summary', 'filename'];
        const candidates = preferredOrder.filter(field => availableFields.includes(field));

        // Fallback to first fields if preferred ones are unavailable in this dataset.
        const fallback = availableFields.slice(0, 3);
        const pickFields = candidates.length ? candidates : fallback;

        pickFields.forEach(field => {
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'search-terms__chip';
            button.dataset.field = field;
            button.textContent = field;
            button.setAttribute('aria-pressed', 'false');
            button.addEventListener('click', function() {
                setField(field);
            });
            quickPicks.appendChild(button);
        });
    }

    fieldSelect.addEventListener('change', function() {
        setField(this.value);
    });

    searchInput.addEventListener('input', function() {
        const nextQuery = this.value.trim();
        clearTimeout(searchDebounceId);
        searchDebounceId = setTimeout(function() {
            searchQuery = nextQuery;
            currentPage = 1;
            fetchData(currentPage);
        }, 250);
    });

    clearSearchButton.addEventListener('click', function() {
        searchInput.value = '';
        searchQuery = '';
        currentPage = 1;
        fetchData(currentPage);
    });

    document.getElementById('prevPage').addEventListener('click', function() {
        if (currentPage > 1) {
            currentPage -= 1;
            fetchData(currentPage);
        }
    });

    document.getElementById('nextPage').addEventListener('click', function() {
        currentPage += 1;
        fetchData(currentPage);
    });

    [wordsTab, phrasesTab].forEach(tab => {
        tab.addEventListener('click', function() {
            activeType = this.dataset.type;
            updateTabs();
            renderRows(latestPayload);
            if (latestPayload) {
                const activeRows = activeType === 'word' ? latestPayload.words : latestPayload.phrases;
                updatePagination(currentPage, activeRows.length === perPage);
            }
        });
    });

    termsTableBody.addEventListener('click', function(event) {
        const copyButton = event.target.closest('[data-copy-term]');
        if (!copyButton) return;

        const term = copyButton.getAttribute('data-copy-term');
        if (!term) return;

        navigator.clipboard.writeText(term).then(function() {
            copyButton.textContent = 'Copied';
            setTimeout(function() {
                copyButton.textContent = 'Copy';
            }, 1000);
        }).catch(function() {
            alert('Failed to copy term to clipboard.');
        });
    });

    function renderCrossTabRows(rows) {
        if (!crossTabBody) return;
        crossTabBody.innerHTML = '';

        rows.forEach(row => {
            const roundedLift = Math.round(Number(row.lift) || 0);
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td class="search-terms__term">${row.term}</td>
                <td>${roundedLift}</td>
                <td>${row.co_doc_count}</td>
                <td>${row.global_doc_count}</td>
                <td class="search-terms__actions">
                    <a class="search-terms__action-link" href="${searchUrlForTerm(row.term)}" data-help="Open Search with this cross-tab term prefilled.">Search</a>
                    <button class="search-terms__action-button" type="button" data-copy-cross-term="${row.term}" data-help="Copy this cross-tab term to the clipboard.">Copy</button>
                </td>
            `;
            crossTabBody.appendChild(tr);
        });
    }

    function runCrossTab() {
        const anchor = (anchorInput.value || '').trim();
        if (!selectedField) {
            crossTabSummary.textContent = 'Select a field before running cross-tab analysis.';
            return;
        }
        if (!anchor) {
            crossTabSummary.textContent = 'Enter an anchor term to run cross-tab analysis.';
            return;
        }

        const params = new URLSearchParams({
            field: selectedField,
            anchor: anchor,
            limit: String(Math.max(1, Number(crossTabLimitInput.value) || 25)),
            min_doc_freq: String(Math.max(1, Number(minDocFreqInput.value) || 5)),
            min_co_docs: String(Math.max(1, Number(minCoDocsInput.value) || 3))
        });

        toggleCrossTabLoading(true);
        fetch(`/search-terms/cross-tab?${params.toString()}`, {
            headers: {
                'X-Requested-With': 'XMLHttpRequest'
            }
        })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                const rows = Array.isArray(data.results) ? data.results : [];
                renderCrossTabRows(rows);

                const analyzed = data.total_docs_analyzed || 0;
                const withAnchor = data.docs_with_anchor || 0;
                const duration = data.duration_ms || 0;
                if (rows.length === 0) {
                    crossTabSummary.textContent = `No disproportionate terms found for "${data.anchor || anchor}" in ${selectedField}. Analyzed ${analyzed} docs in ${duration} ms.`;
                } else {
                    crossTabSummary.textContent = `Showing ${rows.length} terms for "${data.anchor || anchor}" in ${selectedField}. Anchor appears in ${withAnchor}/${analyzed} docs (${Math.round((data.anchor_doc_rate || 0) * 100)}%). Computed in ${duration} ms.`;
                }
            })
            .catch(error => {
                crossTabSummary.textContent = `Cross-tab failed: ${error.message}`;
            })
            .finally(() => {
                toggleCrossTabLoading(false);
            });
    }

    runCrossTabButton.addEventListener('click', runCrossTab);
    anchorInput.addEventListener('keydown', function(event) {
        if (event.key === 'Enter') {
            event.preventDefault();
            runCrossTab();
        }
    });

    crossTabBody.addEventListener('click', function(event) {
        const copyButton = event.target.closest('[data-copy-cross-term]');
        if (!copyButton) return;
        const term = copyButton.getAttribute('data-copy-cross-term');
        if (!term) return;

        navigator.clipboard.writeText(term).then(function() {
            copyButton.textContent = 'Copied';
            setTimeout(function() {
                copyButton.textContent = 'Copy';
            }, 1000);
        }).catch(function() {
            alert('Failed to copy term to clipboard.');
        });
    });

    function initializeExplorer() {
        if (!fieldSelect) {
            showEmptyState('Field selector is unavailable.');
            return;
        }

        const availableFields = Array.from(fieldSelect.options)
            .map(option => option.value)
            .filter(value => value && value.trim() !== '');

        if (availableFields.length === 0) {
            showEmptyState('No searchable fields are available.');
            return;
        }

        buildQuickPicks(availableFields);
        const preferredOrder = ['ocr_text', 'summary', 'filename'];
        const defaultField = preferredOrder.find(field => availableFields.includes(field)) || availableFields[0];
        updateTabs();
        setField(defaultField);
    }

    initializeExplorer();
})();
</script>
{% endblock %}
