{% extends 'base.html' %}
{% block title %}Unique Terms · Historical Document Reader{% endblock %}

{% block content %}
<div class="container search-terms-page">
    <header class="search-terms__header">
        <h1>Unique terms explorer</h1>
        <p>Pick a field, choose words or phrases, then click a term to run a database search.</p>
        <ol class="search-terms__steps">
            <li>Choose a field</li>
            <li>Select words or phrases</li>
            <li>Explore and launch search</li>
        </ol>
    </header>

    <section class="search-terms__panel">
        <h2>Field</h2>
        <div id="fieldQuickPicks" class="search-terms__chips" aria-label="Suggested fields"></div>
        <div class="search-terms__filters">
            <label for="fieldSelect">All fields</label>
            <select id="fieldSelect">
                <option value="" disabled selected>Select a field</option>
                {% for field in field_structure|dictsort %}
                    {% if field[0] not in unique_fields %}
                    <option value="{{ field[0] }}">{{ field[0] }}</option>
                    {% endif %}
                {% endfor %}
            </select>
        </div>
    </section>

    <section class="search-terms__panel">
        <h2>Explore</h2>
        <div class="search-terms__controls">
            <label for="searchInput">Filter terms</label>
            <input type="text" id="searchInput" placeholder="Type to filter terms..." aria-label="Filter terms">
            <button id="clearSearchButton" class="button--secondary" type="button" aria-label="Clear filter">Clear</button>
        </div>

        <div class="search-terms__tabs" role="tablist" aria-label="Term type">
            <button id="wordsTab" class="search-terms__tab is-active" type="button" data-type="word" role="tab" aria-selected="true">Words</button>
            <button id="phrasesTab" class="search-terms__tab" type="button" data-type="phrase" role="tab" aria-selected="false">Phrases</button>
        </div>

        <div class="search-terms__meta">
            <p>Field: <span id="activeField">None</span></p>
            <p>Unique words: <span id="uniqueWords">0</span></p>
            <p>Unique phrases: <span id="uniquePhrases">0</span></p>
            <p>Total records: <span id="totalRecords">0</span></p>
        </div>
        <p id="resultsSummary" class="search-terms__summary">Select a field to load data.</p>

        <div id="loadingIndicator" class="loading-indicator" hidden>
            <div class="spinner"></div>
            <p>Loading data…</p>
        </div>
        <div id="noDataMessage" class="search-terms__empty" hidden></div>

        <div class="search-terms__table-wrapper">
            <table id="termsTable" class="search-terms__table">
                <thead>
                    <tr>
                        <th>Term</th>
                        <th>Count</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="termsTableBody"></tbody>
            </table>
        </div>

        <div class="pagination-controls">
            <button id="prevPage" disabled>Previous</button>
            <span>Page <span id="currentPage">1</span></span>
            <button id="nextPage">Next</button>
        </div>
    </section>

    <template id="termRowTemplate">
        <tr>
            <td class="search-terms__term"></td>
            <td class="search-terms__count"></td>
            <td class="search-terms__actions"></td>
        </tr>
    </template>
</div>
{% endblock %}

{% block scripts %}
{{ super() }}
<script>
(function() {
    // Keep request/response contracts unchanged while improving interaction flow.
    let currentPage = 1;
    const perPage = 100;
    let selectedField = '';
    let searchQuery = '';
    let activeType = 'word';
    let latestPayload = null;
    let searchDebounceId = null;

    const fieldSelect = document.getElementById('fieldSelect');
    const quickPicks = document.getElementById('fieldQuickPicks');
    const searchInput = document.getElementById('searchInput');
    const clearSearchButton = document.getElementById('clearSearchButton');
    const termsTableBody = document.getElementById('termsTableBody');
    const resultsSummary = document.getElementById('resultsSummary');
    const activeField = document.getElementById('activeField');
    const loadingIndicator = document.getElementById('loadingIndicator');
    const noDataMessage = document.getElementById('noDataMessage');
    const wordsTab = document.getElementById('wordsTab');
    const phrasesTab = document.getElementById('phrasesTab');

    function toggleLoading(active) {
        if (!loadingIndicator) return;
        loadingIndicator.hidden = !active;
    }

    function showEmptyState(message) {
        if (!noDataMessage) return;
        noDataMessage.textContent = message || '';
        noDataMessage.hidden = !message;
    }

    function updateMeta(data) {
        document.getElementById('uniqueWords').textContent = data.unique_words;
        document.getElementById('uniquePhrases').textContent = data.unique_phrases;
        document.getElementById('totalRecords').textContent = data.total_records;
        activeField.textContent = selectedField || 'None';
    }

    function updatePagination(page, hasMore) {
        document.getElementById('currentPage').textContent = page;
        document.getElementById('prevPage').disabled = page === 1;
        document.getElementById('nextPage').disabled = !hasMore;
    }

    function updateTabs() {
        const tabs = [wordsTab, phrasesTab];
        tabs.forEach(tab => {
            const isActive = tab.dataset.type === activeType;
            tab.classList.toggle('is-active', isActive);
            tab.setAttribute('aria-selected', String(isActive));
        });
    }

    function normalizeRows(payload) {
        if (!payload) return [];
        const sourceRows = activeType === 'word' ? (payload.words || []) : (payload.phrases || []);
        return sourceRows.map(row => ({
            term: activeType === 'word' ? row.word : row.phrase,
            count: row.count
        }));
    }

    function searchUrlForTerm(term) {
        const params = new URLSearchParams({
            prefill_field: selectedField,
            prefill_term: term
        });
        return `/search?${params.toString()}`;
    }

    function renderRows(payload) {
        const rows = normalizeRows(payload);
        const maxCount = Math.max(...rows.map(row => row.count), 1);

        if (!termsTableBody) return;
        termsTableBody.innerHTML = '';

        rows.forEach(row => {
            const tr = document.createElement('tr');

            const termCell = document.createElement('td');
            termCell.className = 'search-terms__term';
            termCell.textContent = row.term;

            const countCell = document.createElement('td');
            countCell.className = 'search-terms__count';
            const barWidth = Math.max(4, Math.round((row.count / maxCount) * 100));
            countCell.innerHTML = `
                <div class="search-terms__count-wrap">
                    <span>${row.count}</span>
                    <div class="search-terms__count-bar"><span style="width:${barWidth}%"></span></div>
                </div>
            `;

            const actionsCell = document.createElement('td');
            actionsCell.className = 'search-terms__actions';
            // Keep actions explicit for fast pivoting into database search and clipboard workflows.
            actionsCell.innerHTML = `
                <a class="search-terms__action-link" href="${searchUrlForTerm(row.term)}">Search</a>
                <button class="search-terms__action-button" type="button" data-copy-term="${row.term}">Copy</button>
            `;

            tr.appendChild(termCell);
            tr.appendChild(countCell);
            tr.appendChild(actionsCell);
            termsTableBody.appendChild(tr);
        });

        const hasRows = rows.length > 0;
        if (hasRows) {
            resultsSummary.textContent = `Showing ${rows.length} ${activeType === 'word' ? 'words' : 'phrases'} on page ${currentPage}.`;
        } else {
            resultsSummary.textContent = `No ${activeType === 'word' ? 'words' : 'phrases'} match the current filter.`;
        }
    }

    function fetchData(page) {
        if (!selectedField) {
            termsTableBody.innerHTML = '';
            updateMeta({ unique_words: 0, unique_phrases: 0, total_records: 0 });
            updatePagination(1, false);
            showEmptyState('Select a field to load unique terms.');
            return;
        }

        toggleLoading(true);
        showEmptyState('');

        const params = new URLSearchParams({
            field: selectedField,
            page: String(page),
            per_page: String(perPage),
            query: searchQuery
        });

        fetch(`{{ url_for('search_terms') }}?${params.toString()}`, {
            headers: {
                'X-Requested-With': 'XMLHttpRequest'
            }
        })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                latestPayload = data;
                if (data.words.length === 0 && data.phrases.length === 0) {
                    showEmptyState('No data available for the selected field or search query.');
                }
                renderRows(data);
                updateMeta(data);
                const activeRows = activeType === 'word' ? data.words : data.phrases;
                const hasMore = activeRows.length === perPage;
                updatePagination(page, hasMore);
            })
            .catch(error => {
                alert('Error fetching data: ' + error.message);
            })
            .finally(() => {
                toggleLoading(false);
            });
    }

    function setField(fieldName) {
        if (!fieldName) return;
        selectedField = fieldName;
        if (fieldSelect) {
            fieldSelect.value = fieldName;
        }
        currentPage = 1;
        fetchData(currentPage);
        updateQuickPickState();
    }

    function updateQuickPickState() {
        if (!quickPicks) return;
        const buttons = quickPicks.querySelectorAll('button');
        buttons.forEach(button => {
            const isActive = button.dataset.field === selectedField;
            button.classList.toggle('is-active', isActive);
            button.setAttribute('aria-pressed', String(isActive));
        });
    }

    function buildQuickPicks(availableFields) {
        if (!quickPicks) return;
        quickPicks.innerHTML = '';
        const preferredOrder = ['ocr_text', 'summary', 'filename'];
        const candidates = preferredOrder.filter(field => availableFields.includes(field));

        // Fallback to first fields if preferred ones are unavailable in this dataset.
        const fallback = availableFields.slice(0, 3);
        const pickFields = candidates.length ? candidates : fallback;

        pickFields.forEach(field => {
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'search-terms__chip';
            button.dataset.field = field;
            button.textContent = field;
            button.setAttribute('aria-pressed', 'false');
            button.addEventListener('click', function() {
                setField(field);
            });
            quickPicks.appendChild(button);
        });
    }

    fieldSelect.addEventListener('change', function() {
        setField(this.value);
    });

    searchInput.addEventListener('input', function() {
        const nextQuery = this.value.trim();
        clearTimeout(searchDebounceId);
        searchDebounceId = setTimeout(function() {
            searchQuery = nextQuery;
            currentPage = 1;
            fetchData(currentPage);
        }, 250);
    });

    clearSearchButton.addEventListener('click', function() {
        searchInput.value = '';
        searchQuery = '';
        currentPage = 1;
        fetchData(currentPage);
    });

    document.getElementById('prevPage').addEventListener('click', function() {
        if (currentPage > 1) {
            currentPage -= 1;
            fetchData(currentPage);
        }
    });

    document.getElementById('nextPage').addEventListener('click', function() {
        currentPage += 1;
        fetchData(currentPage);
    });

    [wordsTab, phrasesTab].forEach(tab => {
        tab.addEventListener('click', function() {
            activeType = this.dataset.type;
            updateTabs();
            renderRows(latestPayload);
            if (latestPayload) {
                const activeRows = activeType === 'word' ? latestPayload.words : latestPayload.phrases;
                updatePagination(currentPage, activeRows.length === perPage);
            }
        });
    });

    termsTableBody.addEventListener('click', function(event) {
        const copyButton = event.target.closest('[data-copy-term]');
        if (!copyButton) return;

        const term = copyButton.getAttribute('data-copy-term');
        if (!term) return;

        navigator.clipboard.writeText(term).then(function() {
            copyButton.textContent = 'Copied';
            setTimeout(function() {
                copyButton.textContent = 'Copy';
            }, 1000);
        }).catch(function() {
            alert('Failed to copy term to clipboard.');
        });
    });

    function initializeExplorer() {
        if (!fieldSelect) {
            showEmptyState('Field selector is unavailable.');
            return;
        }

        const availableFields = Array.from(fieldSelect.options)
            .map(option => option.value)
            .filter(value => value && value.trim() !== '');

        if (availableFields.length === 0) {
            showEmptyState('No searchable fields are available.');
            return;
        }

        buildQuickPicks(availableFields);
        const preferredOrder = ['ocr_text', 'summary', 'filename'];
        const defaultField = preferredOrder.find(field => availableFields.includes(field)) || availableFields[0];
        updateTabs();
        setField(defaultField);
    }

    initializeExplorer();
})();
</script>
{% endblock %}
