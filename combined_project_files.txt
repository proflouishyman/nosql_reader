Project File Combination
Generated on: 2024-09-19 13:22:31.046188

Total files: 24
File type counts:
  .py: 8
  .md: 1
  .js: 1
  .css: 1
  .html: 9

File Structure:
nosql_reader/
    app.py
    generate_password.py
    models.py
    readme.md
    requirements.txt
    routes.py
    combined_project_files.txt
    data_processing.py
    database_setup.py
    json_validator.py
    json_validator_multi.py
    config.json
    secret_key.txt
    static/
        script.js
        style.css
    templates/
        document-detail.html
        document-list.html
        error.html
        index.html
        search-terms.html
        database-info.html
        settings.html
        base.html
        login.html

********************************************************************************

File: app.py
********************************************************************************

# File: app.py
# Path: railroad_documents_project/app.py

import os
import json
from flask import Flask
from flask_caching import Cache
from flask_session import Session
from database_setup import client, db, documents, field_structure
import logging
from logging.handlers import RotatingFileHandler



app = Flask(__name__)

# Setup file-based logging
if not app.debug:
    file_handler = RotatingFileHandler('logs/app.log', maxBytes=10240, backupCount=10)
    file_handler.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    file_handler.setFormatter(formatter)
    app.logger.addHandler(file_handler)

app.logger.setLevel(logging.DEBUG)


# Load configuration
config_path = os.path.join(os.path.dirname(__file__), 'config.json')
with open(config_path) as config_file:
    config = json.load(config_file)

# Add config to app config
app.config['UI_CONFIG'] = config

# Print out the template folder path for debugging
print(f"Template folder path: {app.template_folder}")

# Session configuration
app.config['SESSION_TYPE'] = 'filesystem'
app.config['SESSION_PERMANENT'] = False
app.config['SESSION_USE_SIGNER'] = True
app.config['SESSION_KEY_PREFIX'] = 'historical_document_reader'

def get_secret_key():
    secret_file = os.path.join(app.root_path, 'secret_key.txt')
    if os.path.exists(secret_file):
        with open(secret_file, 'r') as f:
            return f.read().strip()
    else:
        import secrets
        generated_key = secrets.token_hex(16)
        with open(secret_file, 'w') as f:
            f.write(generated_key)
        return generated_key

# Set the secret key
app.secret_key = get_secret_key()

# Initialize extensions
cache = Cache(config={'CACHE_TYPE': 'simple'})
cache.init_app(app)
Session(app)

def load_config():
    """
    Load the configuration from the JSON file.
    This function is called on each request to allow for dynamic UI configuration.
    """
    config_path = os.path.join(os.path.dirname(__file__), 'config.json')
    with open(config_path) as config_file:
        return json.load(config_file)

def get_field_structure():
    """
    Load the field structure from the MongoDB collection.
    """
    structure = field_structure.find_one({"_id": "current_structure"})
    return structure['structure'] if structure else {}

@app.context_processor
def inject_ui_config():
    """
    Inject the UI configuration and field structure into all templates.
    This allows for dynamic UI customization without needing to pass the config to each template.
    """
    app.config['UI_CONFIG'] = load_config()
    field_struct = get_field_structure()
    return dict(ui_config=app.config['UI_CONFIG'], field_structure=field_struct)

# Import routes after initializing app to avoid circular imports
from routes import *

if __name__ == '__main__':
    # Run the app
    app.run(debug=True)


********************************************************************************

File: generate_password.py
********************************************************************************

from werkzeug.security import generate_password_hash

actual_password = 'loulou'
method = 'pbkdf2:sha256:260000'

password_hash = generate_password_hash(actual_password, method=method)
print(password_hash)



********************************************************************************

File: models.py
********************************************************************************

# No longer necessary since it is NoSQL db. 

# from app import db, ma

# class OCRText(db.Model):
#     __tablename__ = 'ocr_text'
#     id = db.Column(db.Text, primary_key=True)
#     file = db.Column(db.Text, nullable=False)
#     text = db.Column(db.Text, nullable=False)

#     summary = db.relationship('Summary', back_populates='ocr_text', uselist=False)
#     named_entities = db.relationship('NamedEntity', back_populates='ocr_text')
#     dates = db.relationship('Date', back_populates='ocr_text')
#     monetary_amounts = db.relationship('MonetaryAmount', back_populates='ocr_text')
#     relationships = db.relationship('Relationship', back_populates='ocr_text')
#     document_metadata = db.relationship('DocumentMetadata', back_populates='ocr_text', uselist=False)
#     translation = db.relationship('Translation', back_populates='ocr_text', uselist=False)
#     file_info = db.relationship('FileInfo', back_populates='ocr_text', uselist=False)

# class Summary(db.Model):
#     __tablename__ = 'summary'
#     id = db.Column(db.Text, primary_key=True)
#     file = db.Column(db.Text, db.ForeignKey('ocr_text.id'), nullable=False)
#     text = db.Column(db.Text, nullable=False)

#     ocr_text = db.relationship('OCRText', back_populates='summary')

# class NamedEntity(db.Model):
#     __tablename__ = 'named_entities'
#     id = db.Column(db.Text, primary_key=True)
#     file = db.Column(db.Text, db.ForeignKey('ocr_text.id'), nullable=False)
#     entity = db.Column(db.Text, nullable=False)
#     type = db.Column(db.Text, nullable=False)

#     ocr_text = db.relationship('OCRText', back_populates='named_entities')

# class Date(db.Model):
#     __tablename__ = 'dates'
#     id = db.Column(db.Text, primary_key=True)
#     file = db.Column(db.Text, db.ForeignKey('ocr_text.id'), nullable=False)
#     date = db.Column(db.Text, nullable=False)

#     ocr_text = db.relationship('OCRText', back_populates='dates')

# class MonetaryAmount(db.Model):
#     __tablename__ = 'monetary_amounts'
#     id = db.Column(db.Text, primary_key=True)
#     file = db.Column(db.Text, db.ForeignKey('ocr_text.id'), nullable=False)
#     amount = db.Column(db.Text, nullable=False)
#     category = db.Column(db.Text, nullable=False)

#     ocr_text = db.relationship('OCRText', back_populates='monetary_amounts')

# class Relationship(db.Model):
#     __tablename__ = 'relationships'
#     id = db.Column(db.Text, primary_key=True)
#     file = db.Column(db.Text, db.ForeignKey('ocr_text.id'), nullable=False)
#     entity1 = db.Column(db.Text, nullable=False)
#     relationship = db.Column(db.Text, nullable=False)
#     entity2 = db.Column(db.Text, nullable=False)

#     ocr_text = db.relationship('OCRText', back_populates='relationships')

# class DocumentMetadata(db.Model):
#     __tablename__ = 'metadata'
#     id = db.Column(db.Text, primary_key=True)
#     file = db.Column(db.Text, db.ForeignKey('ocr_text.id'), nullable=False)
#     document_type = db.Column(db.Text, nullable=False)
#     period = db.Column(db.Text, nullable=False)
#     context = db.Column(db.Text, nullable=False)
#     sentiment = db.Column(db.Text, nullable=False)

#     ocr_text = db.relationship('OCRText', back_populates='document_metadata')

# class Translation(db.Model):
#     __tablename__ = 'translation'
#     id = db.Column(db.Text, primary_key=True)
#     file = db.Column(db.Text, db.ForeignKey('ocr_text.id'), nullable=False)
#     french_text = db.Column(db.Text, nullable=False)
#     english_translation = db.Column(db.Text, nullable=False)

#     ocr_text = db.relationship('OCRText', back_populates='translation')

# class FileInfo(db.Model):
#     __tablename__ = 'file_info'
#     id = db.Column(db.Text, primary_key=True)
#     file = db.Column(db.Text, db.ForeignKey('ocr_text.id'), nullable=False)
#     original_filepath = db.Column(db.Text, nullable=False)

#     ocr_text = db.relationship('OCRText', back_populates='file_info')

# # Add Marshmallow schemas if needed
# class OCRTextSchema(ma.SQLAlchemyAutoSchema):
#     class Meta:
#         model = OCRText


********************************************************************************

File: readme.md
********************************************************************************

# Historical Document Reader


Organize data ingestion from 
database_setup      creates the db
json_validator      checks texts for inclusion
database_processing ingests the data


##Needed FEatures

2. Ability to mark documents for followup
3. Highlighting of search terms in produced text [attempted to code but difficult]
4. Preloading of next document somehow
5.
6. 
7. mouseover wikipedia search


Architecture:

The application is built using Flask, a Python web framework.
It uses MongoDB as the NoSQL database, accessed via the PyMongo library.
The frontend is created using HTML, CSS, and JavaScript, with some dynamic content rendering.


Main Components:

app.py: The main Flask application file that initializes the app and includes configurations.
routes.py: Contains all the route handlers for different endpoints.
database_setup.py: Manages database connections and operations.
data_processing.py: Handles the ingestion of JSON files into the MongoDB database.
static/script.js: Contains client-side JavaScript for handling user interactions and AJAX requests.
static/style.css: Defines the styling for the application.
Various HTML templates in the templates folder for rendering different pages.


Functionality:

Document Search: Users can search for documents using multiple fields and operators (AND, OR, NOT).
Pagination: Search results are paginated for better performance and user experience.
Document Viewing: Users can view individual documents with their details and associated images.
Database Information: Provides an overview of the database structure and field counts.
Search Terms Analysis: Allows users to explore the frequency of terms in different fields.
Settings: Users can customize UI settings like fonts, colors, and spacing.
Authentication: Basic login functionality is implemented for accessing certain features.


Data Flow:

JSON files are processed and inserted into MongoDB using data_processing.py.
The application dynamically discovers and adapts to the structure of the documents in the database.
Search queries are constructed based on user input and executed against MongoDB.
Results are returned to the frontend and displayed using a combination of server-side rendering and client-side JavaScript.


Notable Features:

Dynamic field structure discovery and adaptation.
Infinite scrolling for search results.
AJAX-based search to improve responsiveness.
Prefetching of next page results for smoother scrolling.
Export to CSV functionality for search results.
Image viewing with zoom and pan capabilities for document images.


Security Measures:

Password protection for certain routes.
CAPTCHA implementation to prevent automated login attempts.
Session management for maintaining user state.



This application provides a flexible and efficient way to search and view historical documents stored in a NoSQL database, with a focus on performance and user experience.

********************************************************************************

File: routes.py
********************************************************************************

# File: routes.py
# Path: railroad_documents_project/routes.py

from flask import request, jsonify, render_template, redirect, url_for, flash, session, abort, Response
from functools import wraps
from app import app, cache
from database_setup import documents, find_document_by_id, find_documents, insert_document, update_document, delete_document, get_field_structure
from bson import ObjectId
from werkzeug.security import generate_password_hash, check_password_hash
import math
import json
import re
import logging
import time
from datetime import datetime, timedelta
import random
import csv
from io import StringIO
from logging.handlers import RotatingFileHandler


# Setup file-based logging
if not app.debug:
    file_handler = RotatingFileHandler('logs/app_routes.log', maxBytes=10240, backupCount=10)
    file_handler.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    file_handler.setFormatter(formatter)
    app.logger.addHandler(file_handler)

app.logger.setLevel(logging.DEBUG)

# Hashed password (generate this using generate_password_hash('your_actual_password'))
ADMIN_PASSWORD_HASH = 'pbkdf2:sha256:260000$uxZ1Fkjt9WQCHwuN$ca37dfb41ebc26b19daf24885ebcd09f607cab85f92dcab13625627fd9ee902a'

# Login attempt tracking
MAX_ATTEMPTS = 5
LOCKOUT_TIME = 15 * 60  # 15 minutes in seconds
login_attempts = {}

def is_locked_out(ip):
    if ip in login_attempts:
        attempts, last_attempt_time = login_attempts[ip]
        if attempts >= MAX_ATTEMPTS:
            if datetime.now() - last_attempt_time < timedelta(seconds=LOCKOUT_TIME):
                return True
            else:
                login_attempts[ip] = (0, datetime.now())
    return False

def update_login_attempts(ip, success):
    if ip in login_attempts:
        attempts, _ = login_attempts[ip]
        if success:
            login_attempts[ip] = (0, datetime.now())
        else:
            login_attempts[ip] = (attempts + 1, datetime.now())
    else:
        login_attempts[ip] = (1, datetime.now()) if not success else (0, datetime.now())

# Login required decorator
def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'logged_in' not in session:
            return redirect(url_for('login', next=request.url))
        return f(*args, **kwargs)
    return decorated_function

@app.route('/')
def index():
    app.logger.info('Handling request to index')
    num_search_fields = 3  # Number of search fields to display
    return render_template('index.html', num_search_fields=num_search_fields)

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        ip = request.remote_addr

        if is_locked_out(ip):
            flash('Too many failed attempts. Please try again later.')
            return render_template('login.html')

        # Verify CAPTCHA
        user_captcha = request.form.get('captcha')
        correct_captcha = request.form.get('captcha_answer')
        if user_captcha != correct_captcha:
            flash('Incorrect CAPTCHA')
            return redirect(url_for('login'))

        if check_password_hash(ADMIN_PASSWORD_HASH, request.form['password']):
            session['logged_in'] = True
            update_login_attempts(ip, success=True)
            flash('You were successfully logged in')
            next_page = request.args.get('next')
            return redirect(next_page or url_for('index'))
        else:
            update_login_attempts(ip, success=False)
            time.sleep(2)  # Add a delay after failed attempt
            flash('Invalid password')

    # Generate CAPTCHA for GET requests
    captcha_num1 = random.randint(1, 10)
    captcha_num2 = random.randint(1, 10)
    captcha_answer = str(captcha_num1 + captcha_num2)

    return render_template('login.html', captcha_num1=captcha_num1, captcha_num2=captcha_num2, captcha_answer=captcha_answer)

@app.route('/logout')
def logout():
    session.pop('logged_in', None)
    flash('You were logged out')
    return redirect(url_for('index'))



@app.route('/search', methods=['GET', 'POST'])
def search():
    try:
        if request.method == 'POST':
            # Log incoming request data
            data = request.get_json()
            logging.debug(f"Received POST search request: {data}")

            # Extract pagination details
            page = int(data.get('page', 1))
            per_page = int(data.get('per_page', 50))
            logging.debug(f"Pagination details - Page: {page}, Per Page: {per_page}")

            # Build query based on user input
            query = build_query(data)
            logging.debug(f"Constructed MongoDB query: {query}")

            # Query MongoDB for the matching documents
            total_count = documents.count_documents(query)
            search_results = documents.find(query).skip((page - 1) * per_page).limit(per_page)
            documents_list = list(search_results)

            logging.debug(f"Total matching documents: {total_count}, Returned documents: {len(documents_list)}")

            # Convert ObjectId to string for each document
            for doc in documents_list:
                doc['_id'] = str(doc['_id'])

            # Calculate total pages
            total_pages = math.ceil(total_count / per_page)

            logging.debug(f"Total pages: {total_pages}, Current page: {page}")

            # Render the search results page
            return render_template('search_results.html',
                                   documents=documents_list,
                                   total_count=total_count,
                                   current_page=page,
                                   total_pages=total_pages,
                                   per_page=per_page)

        else:
            # For GET requests, simply render the search form
            num_search_fields = 3
            logging.debug(f"Rendering search page with {num_search_fields} fields")
            return render_template('search.html', num_search_fields=num_search_fields)

    except Exception as e:
        logging.error(f"An error occurred during search: {str(e)}", exc_info=True)
        return jsonify({"error": "An internal error occurred"}), 500

def build_query(data):
    """
    Build a MongoDB query from the search criteria provided by the user.
    """
    query = {}
    criteria_list = []

    logging.debug(f"Building query from search data: {data}")

    for i in range(1, 4):
        field = data.get(f'field{i}')
        search_term = data.get(f'searchTerm{i}')
        operator = data.get(f'operator{i}')

        if field and search_term:
            condition = {}
            if operator == 'NOT':
                condition[field] = {'$not': {'$regex': search_term, '$options': 'i'}}
            else:
                condition[field] = {'$regex': search_term, '$options': 'i'}
            
            criteria_list.append((operator, condition))
            logging.debug(f"Processed field {field} with search term '{search_term}' and operator '{operator}'")

    # Build the query based on operators (AND, OR, NOT)
    if criteria_list:
        and_conditions = []
        or_conditions = []

        for operator, condition in criteria_list:
            if operator == 'AND' or operator == 'NOT':
                and_conditions.append(condition)
            elif operator == 'OR':
                or_conditions.append(condition)

        # Add AND conditions to the query
        if and_conditions:
            query['$and'] = and_conditions

        # Add OR conditions to the query
        if or_conditions:
            if '$or' not in query:
                query['$or'] = or_conditions
            else:
                query['$or'].extend(or_conditions)

    logging.debug(f"Final query: {query}")
    return query


@app.route('/document/<string:doc_id>')
@login_required
def document_detail(doc_id):
    try:
        document = find_document_by_id(doc_id)
        if not document:
            abort(404)

        document['_id'] = str(document['_id'])

        prev_doc = documents.find_one({'_id': {'$lt': ObjectId(doc_id)}}, sort=[('_id', -1)])
        next_doc = documents.find_one({'_id': {'$gt': ObjectId(doc_id)}}, sort=[('_id', 1)])

        prev_id = str(prev_doc['_id']) if prev_doc else None
        next_id = str(next_doc['_id']) if next_doc else None

        return render_template('document-detail.html', document=document, prev_id=prev_id, next_id=next_id)
    except Exception as e:
        logger.error(f"Error in document_detail: {str(e)}")
        abort(500)

@app.route('/settings', methods=['GET', 'POST'])
@login_required
def settings():
    config_path = os.path.join(os.path.dirname(__file__), 'config.json')

    if request.method == 'POST':
        new_config = request.form.to_dict()

        for key in ['fonts', 'sizes', 'colors', 'spacing']:
            if key in new_config:
                new_config[key] = json.loads(new_config[key])

        with open(config_path, 'w') as config_file:
            json.dump(new_config, config_file, indent=4)

        app.config['UI_CONFIG'] = new_config

        flash('Settings updated successfully', 'success')
        return redirect(url_for('settings'))

    with open(config_path) as config_file:
        config = json.load(config_file)

    return render_template('settings.html', config=config)

@app.route('/search-terms')
@login_required
def search_terms():
    field = request.args.get('field', None)
    if not field:
        return jsonify({"error": "No field specified"}), 400

    pipeline = [
        {'$unwind': f'${field}'},
        {'$group': {'_id': f'${field}', 'count': {'$sum': 1}}},
        {'$sort': {'count': -1}}
    ]

    terms = list(documents.aggregate(pipeline))

    unique_terms = len(terms)
    total_records = documents.count_documents({})

    data = {
        'terms': [{'term': str(term['_id']), 'count': term['count']} for term in terms],
        'unique_terms': unique_terms,
        'total_records': total_records
    }

    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        return jsonify(data)

    return render_template('search-terms.html', **data)

@app.route('/database-info')
@login_required
def database_info():
    field_struct = get_field_structure()
    collection_info = []

    def count_documents_with_field(field_path):
        count = documents.count_documents({field_path: {'$exists': True}})
        return count

    def traverse_structure(structure, current_path=''):
        for field, value in structure.items():
            path = f"{current_path}.{field}" if current_path else field
            if isinstance(value, dict):
                traverse_structure(value, current_path=path)
            else:
                count = count_documents_with_field(path)
                collection_info.append({
                    'name': path,
                    'count': count
                })

    traverse_structure(field_struct)

    return render_template('database-info.html', collection_info=collection_info)

@app.route('/export_csv', methods=['POST'])
@login_required
def export_csv():
    data = request.get_json()
    query = build_query(data)

    results = documents.find(query)

    output = StringIO()
    writer = csv.writer(output)
    # Get field names from field_structure
    field_struct = get_field_structure()
    field_names = []

    def get_field_names(structure, prefix=''):
        for key, value in structure.items():
            if isinstance(value, dict):
                get_field_names(value, prefix=prefix + key + '.')
            else:
                field_names.append(prefix + key)

    get_field_names(field_struct)

    writer.writerow(['ID'] + field_names)

    for result in results:
        row = [str(result.get('_id', ''))]
        for field in field_names:
            # Use dot notation to get nested fields
            keys = field.split('.')
            value = result
            for key in keys:
                if isinstance(value, dict):
                    value = value.get(key, '')
                else:
                    value = ''
                    break
            row.append(value)
        writer.writerow(row)

    return Response(
        output.getvalue(),
        mimetype="text/csv",
        headers={"Content-disposition": "attachment; filename=search_results.csv"}
    )

@app.errorhandler(404)
def not_found_error(error):
    return render_template('error.html', message='Page not found'), 404

@app.errorhandler(500)
def internal_error(error):
    return render_template('error.html', message='An unexpected error has occurred'), 500


********************************************************************************

File: data_processing.py
********************************************************************************

# File: data_processing.py
# Path: railroad_documents_project/data_processing.py

import os
import json
from database_setup import documents, insert_document, update_field_structure
from tqdm import tqdm
import time

def load_json_file(file_path):
    """
    Load a JSON file and return its content as a dictionary.

    :param file_path: The path to the JSON file
    :return: The JSON content as a dictionary, or None if an error occurs
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            return json.load(file)
    except json.JSONDecodeError as e:
        print(f"Error decoding JSON in {file_path}: {str(e)}")
        return None
    except Exception as e:
        print(f"Error reading file {file_path}: {str(e)}")
        return None

def process_file(file_path):
    """
    Process a single JSON file: load it, add filename, update field structure.

    :param file_path: The path to the JSON file
    :return: The loaded JSON data with filename added, or None if an error occurs
    """
    filename = os.path.basename(file_path)
    json_data = load_json_file(file_path)
    if json_data:
        # Add filename as a field if it's not already present
        if 'filename' not in json_data:
            json_data['filename'] = filename
        update_field_structure(json_data)  # Update field structure for each new document
        return json_data
    return None

def process_directory(directory_path):
    """
    Process all JSON files in a directory: delete existing documents, insert new ones, update field structure.

    :param directory_path: The path to the directory containing JSON files
    """
    # Delete all documents from the documents collection
    print("Deleting all existing documents from the database...")
    result = documents.delete_many({})
    print(f"Deleted {result.deleted_count} documents from the database.")

    # Clear the existing field structure
    print("Clearing existing field structure...")
    from database_setup import field_structure
    field_structure.delete_many({})
    print("Field structure cleared.")

    start_time = time.time()
    files_to_process = [f for f in os.listdir(directory_path) if f.endswith('.json')]
    total_files = len(files_to_process)
    
    processed_files = 0
    error_files = 0

    progress_bar = tqdm(files_to_process, desc="Processing files", unit="file")

    for filename in progress_bar:
        file_path = os.path.join(directory_path, filename)
        try:
            document = process_file(file_path)
            if document:
                inserted_id = insert_document(document)
                if inserted_id:
                    processed_files += 1
                else:
                    error_files += 1
            else:
                error_files += 1
        except Exception as e:
            error_files += 1
            print(f"\nError processing {filename}: {str(e)}")
        
        progress_bar.set_postfix({
            "Processed": processed_files,
            "Errors": error_files
        })

    end_time = time.time()
    duration = end_time - start_time

    print("\nProcessing complete!")
    print(f"Total files: {total_files}")
    print(f"Successfully processed: {processed_files}")
    print(f"Errors: {error_files}")
    print(f"Time taken: {duration:.2f} seconds")

if __name__ == "__main__":
    data_directory = r'G:\My Drive\2024-2025\coding\rolls_txt\scratch4\lhyman6\OCR\data\borr\rolls'  # Change this to the path of your JSON files directory
    process_directory(data_directory)


********************************************************************************

File: database_setup.py
********************************************************************************

# File: database_setup.py
# Path: railroad_documents_project/database_setup.py

from pymongo import MongoClient
from bson import ObjectId

# Connect to MongoDB
client = MongoClient('mongodb://localhost:27017/')
db = client['railroad_documents']
documents = db['documents']
field_structure = db['field_structure']

def discover_fields(document):
    """
    Recursively discover fields in a document.
    
    :param document: The document to analyze
    :return: A dictionary representing the field structure
    """
    structure = {}
    for key, value in document.items():
        if isinstance(value, dict):
            structure[key] = discover_fields(value)
        elif isinstance(value, list):
            if value:
                if isinstance(value[0], dict):
                    structure[key] = [discover_fields(value[0])]
                else:
                    structure[key] = [type(value[0]).__name__]
            else:
                structure[key] = []
        else:
            structure[key] = type(value).__name__
    return structure

def merge_structures(existing, new):
    """
    Merge two field structures.
    
    :param existing: The existing field structure
    :param new: The new field structure to merge
    :return: The merged field structure
    """
    for key, value in new.items():
        if key not in existing:
            existing[key] = value
        elif isinstance(value, dict) and isinstance(existing[key], dict):
            merge_structures(existing[key], value)
        elif isinstance(value, list) and isinstance(existing[key], list):
            if value and existing[key]:
                if isinstance(value[0], dict) and isinstance(existing[key][0], dict):
                    merge_structures(existing[key][0], value[0])
    return existing

def update_field_structure(document):
    """
    Update the field structure based on a new document.
    
    :param document: The new document to analyze
    """
    new_structure = discover_fields(document)
    existing_structure = field_structure.find_one({"_id": "current_structure"})
    
    if existing_structure:
        merged_structure = merge_structures(existing_structure['structure'], new_structure)
        field_structure.update_one(
            {"_id": "current_structure"},
            {"$set": {"structure": merged_structure}},
            upsert=True
        )
    else:
        field_structure.insert_one({"_id": "current_structure", "structure": new_structure})

def get_field_structure():
    """
    Get the current field structure.
    
    :return: The current field structure
    """
    structure = field_structure.find_one({"_id": "current_structure"})
    return structure['structure'] if structure else {}

def insert_document(document_data):
    """
    Insert a new document into the database.
    
    :param document_data: A dictionary containing the document's information
    :return: The ObjectId of the inserted document
    """
    result = documents.insert_one(document_data)
    return result.inserted_id

def find_document_by_id(document_id):
    """
    Find a document by its ObjectId.
    
    :param document_id: The ObjectId of the document
    :return: The document, or None if not found
    """
    return documents.find_one({"_id": ObjectId(document_id)})

def find_documents(query, limit=10):
    """
    Find documents based on a query.
    
    :param query: A dictionary containing the search criteria
    :param limit: Maximum number of results to return (default 10)
    :return: A cursor containing the matching documents
    """
    return documents.find(query).limit(limit)

def update_document(document_id, update_data):
    """
    Update a document's information.
    
    :param document_id: The ObjectId of the document to update
    :param update_data: A dictionary containing the fields to update
    :return: The result of the update operation
    """
    result = documents.update_one({"_id": ObjectId(document_id)}, {"$set": update_data})
    return result.modified_count

def delete_document(document_id):
    """
    Delete a document from the database.
    
    :param document_id: The ObjectId of the document to delete
    :return: The result of the delete operation
    """
    result = documents.delete_one({"_id": ObjectId(document_id)})
    return result.deleted_count

# Create a text index for full-text search on all string fields
documents.create_index([("$**", "text")])

if __name__ == "__main__":
    # Recalculate the field structure based on existing documents
    print("Initializing field structure...")
    field_structure.delete_many({})  # Clear existing field structure
    all_documents = documents.find()
    for doc in all_documents:
        update_field_structure(doc)
    print("Field structure initialized.")


********************************************************************************

File: json_validator.py
********************************************************************************

import os
import json
import re
import multiprocessing
from tqdm import tqdm

def clean_json(json_text):
    # Remove all control characters
    json_text = re.sub(r'[\x00-\x1F\x7F]', '', json_text)

    # Find the index of the first '{' and the last '}'
    start_index = json_text.find('{')
    end_index = json_text.rfind('}')

    # Extract the clean JSON string
    if start_index != -1 and end_index != -1:
        clean_json_text = json_text[start_index:end_index + 1]
        return clean_json_text
    else:
        raise ValueError("Invalid JSON format: Unable to find '{' or '}'.")

def validate_json_file(file_path):
    filename = os.path.basename(file_path)
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            json_content = file.read()

        # Clean the JSON content before validation
        cleaned_json_content = clean_json(json_content)
        cleaned = cleaned_json_content != json_content

        # Validate the cleaned JSON content
        json_data = json.loads(cleaned_json_content)

        # Define the new file path with .json extension
        base_name, _ = os.path.splitext(file_path)
        new_file_path = f"{base_name}.json"

        # Write the validated and cleaned JSON to the new file
        with open(new_file_path, 'w', encoding='utf-8') as file:
            json.dump(json_data, file, indent=4)

        # Remove the original .txt file
        os.remove(file_path)

        return (filename, True, cleaned)
    except Exception as e:
        return (filename, False, str(e))

def validate_and_replace_json_files(source_dir, num_workers):
    # Collect all .txt file paths recursively
    file_paths = []
    for root, dirs, files in os.walk(source_dir):
        for f in files:
            if f.lower().endswith('.txt'):
                file_paths.append(os.path.join(root, f))
    total_files = len(file_paths)

    print(f"Processing {total_files} .txt files with {num_workers} worker processes...")

    # Initialize counters
    cleaned_count = 0
    replaced_count = 0
    invalid_count = 0

    # Use multiprocessing Pool to process files in parallel
    with multiprocessing.Pool(num_workers) as pool:
        # Use imap_unordered for better performance and integrate with tqdm
        results = []
        for result in tqdm(pool.imap_unordered(validate_json_file, file_paths), total=total_files, desc="Validating JSON files"):
            results.append(result)

    # Process the results
    for filename, is_valid, info in results:
        if is_valid:
            if info:
                cleaned_count += 1
            replaced_count += 1
        else:
            invalid_count += 1

    print(f"\nProcessing complete:")
    print(f"Valid JSON files replaced with .json: {replaced_count}")
    print(f"Files cleaned: {cleaned_count}")
    print(f"Invalid or unreadable files remain as .txt: {invalid_count}")

    print("\nDetailed results:")
    for filename, is_valid, info in results:
        if is_valid:
            if info:
                print(f"{filename} was cleaned and replaced with a .json file.")
            else:
                print(f"{filename} is valid and replaced with a .json file.")
        else:
            print(f"{filename} is invalid or unreadable. Remains as .txt. Error: {info}")

if __name__ == "__main__":
    # Specify the source directory
    source_directory = r"G:\My Drive\2024-2025\coding\rolls_txt"

    # Calculate the number of worker processes (3/4 of available CPUs)
    num_cpus = multiprocessing.cpu_count()
    num_workers = max(1, int(num_cpus * 0.75))

    # Start the validation and replacement process
    validate_and_replace_json_files(source_directory, num_workers)


********************************************************************************

File: json_validator_multi.py
********************************************************************************

import os
import json
import re
import multiprocessing
from tqdm import tqdm

def clean_json(json_text):
    # Remove all control characters
    json_text = re.sub(r'[\x00-\x1F\x7F]', '', json_text)

    # Find the index of the first '{' and the last '}'
    start_index = json_text.find('{')
    end_index = json_text.rfind('}')

    # Extract the clean JSON string
    if start_index != -1 and end_index != -1:
        clean_json_text = json_text[start_index:end_index + 1]
        return clean_json_text
    else:
        raise ValueError("Invalid JSON format: Unable to find '{' or '}'.")

def validate_json_file(file_path):
    filename = os.path.basename(file_path)
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            json_content = file.read()

        # Clean the JSON content before validation
        cleaned_json_content = clean_json(json_content)
        cleaned = cleaned_json_content != json_content

        # Validate the cleaned JSON content
        json_data = json.loads(cleaned_json_content)

        # Define the new file path with .json extension
        base_name, _ = os.path.splitext(file_path)
        new_file_path = f"{base_name}.json"

        # Write the validated and cleaned JSON to the new file
        with open(new_file_path, 'w', encoding='utf-8') as file:
            json.dump(json_data, file, indent=4)

        # Remove the original .txt file
        os.remove(file_path)

        return (filename, True, cleaned)
    except Exception as e:
        return (filename, False, str(e))

def validate_and_replace_json_files(source_dir, num_workers):
    # Collect all .txt file paths recursively
    file_paths = []
    for root, dirs, files in os.walk(source_dir):
        for f in files:
            if f.lower().endswith('.txt'):
                file_paths.append(os.path.join(root, f))
    total_files = len(file_paths)

    print(f"Processing {total_files} .txt files with {num_workers} worker processes...")

    # Initialize counters
    cleaned_count = 0
    replaced_count = 0
    invalid_count = 0

    # Use multiprocessing Pool to process files in parallel
    with multiprocessing.Pool(num_workers) as pool:
        # Use imap_unordered for better performance and integrate with tqdm
        results = []
        for result in tqdm(pool.imap_unordered(validate_json_file, file_paths), total=total_files, desc="Validating JSON files"):
            results.append(result)

    # Process the results
    for filename, is_valid, info in results:
        if is_valid:
            if info:
                cleaned_count += 1
            replaced_count += 1
        else:
            invalid_count += 1

    print(f"\nProcessing complete:")
    print(f"Valid JSON files replaced with .json: {replaced_count}")
    print(f"Files cleaned: {cleaned_count}")
    print(f"Invalid or unreadable files remain as .txt: {invalid_count}")

    print("\nDetailed results:")
    for filename, is_valid, info in results:
        if is_valid:
            if info:
                print(f"{filename} was cleaned and replaced with a .json file.")
            else:
                print(f"{filename} is valid and replaced with a .json file.")
        else:
            print(f"{filename} is invalid or unreadable. Remains as .txt. Error: {info}")

if __name__ == "__main__":
    # Specify the source directory
    source_directory = r"G:\My Drive\2024-2025\coding\rolls_txt"

    # Calculate the number of worker processes (3/4 of available CPUs)
    num_cpus = multiprocessing.cpu_count()
    num_workers = max(1, int(num_cpus * 0.75))

    # Start the validation and replacement process
    validate_and_replace_json_files(source_directory, num_workers)


********************************************************************************

File: static\script.js
********************************************************************************

// File: static/script.js

document.addEventListener('DOMContentLoaded', function() {
    const searchForm = document.getElementById('searchForm');
    const resultsDiv = document.getElementById('results');
    const loadingIndicator = document.getElementById('loadingIndicator');
    const cancelButton = document.getElementById('cancelSearch');
    const totalResultsDiv = document.getElementById('totalResults');

    // Add console warnings for missing elements
    if (!searchForm) console.warn('Search form not found');
    if (!resultsDiv) console.warn('Results div not found');
    if (!loadingIndicator) console.warn('Loading indicator not found');
    if (!cancelButton) console.warn('Cancel button not found');
    if (!totalResultsDiv) console.warn('Total results div not found');

    let controller;
    let page = 1;
    let totalPages = 1;
    const perPage = 50;  // Fixed number of results per request
    let totalResults = 0;
    let isLoading = false;
    let hasMore = true;
    let currentQuery = {};
    let prefetchedData = null; // Declare prefetchedData

    // Handle form submission
    if (searchForm) {
        searchForm.addEventListener('submit', function(e) {
            e.preventDefault();
            // Reset variables
            page = 1;
            hasMore = true;
            if (resultsDiv) resultsDiv.innerHTML = '';
            if (totalResultsDiv) totalResultsDiv.textContent = '';
            
            // Get search parameters
            const formData = new FormData(searchForm);
            currentQuery = {};
            for (let i = 1; i <= 3; i++) {
                currentQuery[`field${i}`] = formData.get(`field${i}`);
                currentQuery[`operator${i}`] = formData.get(`operator${i}`);
                currentQuery[`searchTerm${i}`] = formData.get(`searchTerm${i}`);
            }

            // Check if form fields have valid values before proceeding
            if (!currentQuery['field1'] || !currentQuery['searchTerm1']) {
                console.error('Please enter a valid search term in the first field.');
                return;
            }

            performSearch(true);
        });
    }

    // Cancel search functionality
    if (cancelButton) {
        cancelButton.addEventListener('click', function() {
            if (controller) {
                controller.abort();
                hideLoadingIndicator();
                isLoading = false;
                hasMore = false;
                if (cancelButton) cancelButton.style.display = 'none';
            }
        });
    }

    // Function to fetch results
    function performSearch(isNewSearch = false) {
        if (isLoading || !hasMore) return;
        isLoading = true;

        if (isNewSearch) {
            // Clear prefetched data on new search
            prefetchedData = null;
        }

        showLoadingIndicator();
        if (cancelButton) cancelButton.style.display = 'inline-block';

        // Add page and perPage to currentQuery
        currentQuery.page = page;
        currentQuery.per_page = perPage;

        controller = new AbortController();
        const signal = controller.signal;

        fetch('/search', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(currentQuery),
            signal: signal
        })
        .then(response => response.json())
        .then(data => {
            hideLoadingIndicator();
            if (cancelButton) cancelButton.style.display = 'none';
            if (data.documents && data.documents.length > 0) {
                appendResults(data.documents);
                totalPages = data.total_pages;
                totalResults = data.total_count;

                // Prefetch the next page if there are more pages
                if (page < totalPages) {
                    page += 1;
                    prefetchNextPage();
                } else {
                    hasMore = false;
                }
            } else {
                hasMore = false;
                if (isNewSearch && resultsDiv && resultsDiv.innerHTML === '') {
                    resultsDiv.innerHTML = '<p>No results found.</p>';
                }
            }
            updateTotalResults();
            isLoading = false;
        })
        .catch(error => {
            hideLoadingIndicator();
            if (cancelButton) cancelButton.style.display = 'none';
            isLoading = false;
            if (error.name === 'AbortError') {
                console.log('Search was cancelled');
            } else {
                console.error('Error:', error);
            }
        });
    }

    function showLoadingIndicator() {
        if (loadingIndicator && loadingIndicator.style) {
            loadingIndicator.style.display = 'block';
        }
    }

    function hideLoadingIndicator() {
        if (loadingIndicator && loadingIndicator.style) {
            loadingIndicator.style.display = 'none';
        }
    }

    // Function to prefetch the next page of results
    function prefetchNextPage() {
        if (prefetchedData || !hasMore) return;

        const prefetchQuery = { ...currentQuery, page: page };

        fetch('/search', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(prefetchQuery),
        })
        .then(response => response.json())
        .then(data => {
            if (data.documents && data.documents.length > 0) {
                prefetchedData = data;
            } else {
                hasMore = false;
            }
        })
        .catch(error => {
            console.error('Error during prefetching:', error);
        });
    }

    // Infinite scroll logic with debounce
    let debounceTimeout;
    window.addEventListener('scroll', function() {
        clearTimeout(debounceTimeout);
        debounceTimeout = setTimeout(function() {
            const scrollPosition = window.innerHeight + window.scrollY;
            const threshold = document.body.offsetHeight - 100;

            if (scrollPosition >= threshold) {
                if (prefetchedData) {
                    // Use prefetched data
                    appendResults(prefetchedData.documents);
                    page += 1;
                    totalPages = prefetchedData.total_pages;
                    totalResults = prefetchedData.total_count;
                    updateTotalResults();

                    // Clear prefetched data and prefetch the next page
                    prefetchedData = null;
                    if (page <= totalPages) {
                        prefetchNextPage();
                    } else {
                        hasMore = false;
                    }
                } else {
                    performSearch();
                }
            } else if (prefetchedData === null && (scrollPosition >= threshold / 2)) {
                // Start prefetching when user scrolls halfway
                prefetchNextPage();
            }
        }, 200);
    });

    // Function to append results to the page
    function appendResults(documents) {
        if (!resultsDiv) return;

        let table = document.getElementById('resultsTable');
        let tbody;

        // If the table doesn't exist yet, create it
        if (!table) {
            table = document.createElement('table');
            table.id = 'resultsTable';

            // Create table headers
            const thead = document.createElement('thead');
            thead.innerHTML = `
                <tr>
                    <th>File</th>
                    <th>Summary</th>
                </tr>
            `;
            table.appendChild(thead);

            // Create table body
            tbody = document.createElement('tbody');
            table.appendChild(tbody);

            // Append the table to the results div
            resultsDiv.appendChild(table);
        } else {
            // If the table exists, get its tbody
            tbody = table.querySelector('tbody');
        }

        // Append new rows to the table body
        documents.forEach(doc => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td><a href="/document/${doc._id}">${doc.filename || 'No file name'}</a></td>
                <td>${doc.summary || 'No summary available.'}</td>
            `;
            tbody.appendChild(row);
        });
    }

    // Function to update total results display
    function updateTotalResults() {
        if (totalResultsDiv) {
            totalResultsDiv.textContent = `Total results: ${totalResults}`;
        }
    }

    // Export to CSV functionality
    const exportCsvButton = document.getElementById('exportCsv');
    if (exportCsvButton) {
        exportCsvButton.addEventListener('click', function() {
            if (!searchForm) return;

            const formData = new FormData(searchForm);
            const searchData = {
                fields: []
            };

            for (let i = 1; i <= 3; i++) {
                const field = formData.get(`field${i}`);
                const operator = formData.get(`operator${i}`);
                const searchTerm = formData.get(`searchTerm${i}`);
                
                if (field && operator && searchTerm) {
                    searchData.fields.push({
                        field: field,
                        operator: operator,
                        searchTerm: searchTerm
                    });
                }
            }

            fetch('/export_csv', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(searchData)
            })
            .then(response => response.blob())
            .then(blob => {
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = 'search_results.csv';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
            })
            .catch(error => console.error('Error:', error));
        });
    }
});

********************************************************************************

File: static\style.css
********************************************************************************

/* static/style.css */

body {
    font-family: 'Open Sans', sans-serif;
    font-size: 16px;
    line-height: 1.6;
    background-color: #ffffff;
    color: #333;
    margin: 0;
    padding: 0;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

h1, h2, h3 {
    font-family: 'Montserrat', sans-serif;
    color: #333;
    margin-bottom: 20px;
}

/* Navigation */
nav ul {
    list-style-type: none;
    padding: 0;
    margin-bottom: 20px;
}

nav ul li {
    display: inline;
    margin-right: 10px;
}

nav ul li a {
    text-decoration: none;
    color: #007bff;
}

nav ul li a:hover {
    text-decoration: underline;
}

/* Search Form */
.search-field {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    align-items: center;
}

input[type="text"], select {
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 16px;
}

button {
    padding: 10px 20px;
    background-color: #007bff;
    color: #fff;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s ease;
    font-size: 16px;
}

button:hover {
    background-color: #0056b3;
}

/* Results Table */
#results table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
}

#results th, #results td {
    padding: 12px;
    text-align: left;
    border-bottom: 1px solid #ddd;
}

#results th {
    background-color: #f0f0f0;
    font-weight: bold;
}

#results tbody tr:nth-child(odd) {
    background-color: #f9f9f9;
}

#results tbody tr:nth-child(even) {
    background-color: #ffffff;
}

#results tbody tr:hover {
    background-color: #eaeaea;
}

#results a {
    color: #007bff;
    text-decoration: none;
}

#results a:hover {
    text-decoration: underline;
}

/* Loading Indicator */
#loadingIndicator {
    text-align: center;
    margin-top: 20px;
}

.spinner {
    border: 4px solid #f3f3f3;
    border-top: 4px solid #3498db;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    animation: spin 1s linear infinite;
    margin: 0 auto;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Additional Styles */
.mt-4 {
    margin-top: 1rem;
}

.ml-auto {
    margin-left: auto;
}

/* Error Messages */
.error {
    color: #dc3545;
    font-weight: bold;
}

/* Document Detail Styles */
.document-detail .detail-container {
    display: flex;
    gap: 20px;
}

.document-detail .info-panel {
    flex: 1;
}

.document-detail .image-panel {
    flex: 1;
    position: relative;
}

#imageContainer {
    overflow: auto;
    max-width: 100%;
    max-height: 600px;
}

#documentImage {
    max-width: 100%;
    max-height: 100%;
    transform-origin: top left;
}

.zoom-controls {
    margin-top: 10px;
}

.zoom-controls button {
    margin-right: 5px;
}



/* Loading Indicator */
#loadingIndicator {
    text-align: center;
    margin-top: 20px;
}

.spinner {
    border: 4px solid #f3f3f3;
    border-top: 4px solid #3498db;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    animation: spin 1s linear infinite;
    margin: 0 auto;
}


********************************************************************************

File: templates\document-detail.html
********************************************************************************

{% extends "base.html" %}

{% block content %}
<div class="document-detail">
  <div class="detail-container">
    <div class="info-panel">
      <div class="navigation">
        <a href="{{ url_for('index') }}?return_to_search=true" class="nav-button" title="Return to Search Results">
          <i class="fas fa-search"></i>
        </a>
        <a href="{{ prev_id and url_for('document_detail', doc_id=prev_id) or '#' }}" class="nav-button {{ 'disabled' if not prev_id else '' }}" title="Previous Result">
          <i class="fas fa-chevron-left"></i>
        </a>
        <a href="{{ url_for('index') }}" class="nav-button" title="Home">
          <i class="fas fa-home"></i>
        </a>
        <a href="{{ next_id and url_for('document_detail', doc_id=next_id) or '#' }}" class="nav-button {{ 'disabled' if not next_id else '' }}" title="Next Result">
          <i class="fas fa-chevron-right"></i>
        </a>
      </div>
  
      <h1>{{ document.get('filename', 'Untitled Document') }}</h1>

      <table class="info-table">
        <tbody>
          {% for key, value in document.items() %}
            {% if key != '_id' and key != 'filename' %}
              <tr>
                <th>{{ key|title }}</th>
                <td>
                  {% if value is mapping %}
                    {% for subkey, subvalue in value.items() %}
                      <strong>{{ subkey }}:</strong> {{ subvalue }}<br>
                    {% endfor %}
                  {% elif value is iterable and value is not string %}
                    {% for item in value %}
                      {% if item is mapping %}
                        {% for subkey, subvalue in item.items() %}
                          <strong>{{ subkey }}:</strong> {{ subvalue }}<br>
                        {% endfor %}
                      {% else %}
                        {{ item }}<br>
                      {% endif %}
                    {% endfor %}
                  {% else %}
                    {{ value }}
                  {% endif %}
                </td>
              </tr>
            {% endif %}
          {% endfor %}
        </tbody>
      </table>
    </div>

    <div class="image-panel">
      {% if document.get('file_info', {}).get('original_filepath') %}
        <div id="imageContainer">
          <img id="documentImage" src="{{ url_for('serve_image', filename=document['file_info']['original_filepath']) }}" alt="Document Image">
        </div>
        <div class="zoom-controls">
          <button id="zoomIn">Zoom In</button>
          <button id="zoomOut">Zoom Out</button>
          <button id="resetZoom">Reset</button>
        </div>
      {% else %}
        <div class="placeholder-image">
          [Placeholder for Document Image]
        </div>
      {% endif %}
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
  let scale = 1;
  const ZOOM_STEP = 0.1;
  const MAX_SCALE = 3;
  const MIN_SCALE = 0.5;

  const imageContainer = document.getElementById('imageContainer');
  const documentImage = document.getElementById('documentImage');
  const zoomInBtn = document.getElementById('zoomIn');
  const zoomOutBtn = document.getElementById('zoomOut');
  const resetZoomBtn = document.getElementById('resetZoom');

  function setImageTransform() {
    documentImage.style.transform = `scale(${scale})`;
  }

  function zoomIn() {
    if (scale < MAX_SCALE) {
      scale += ZOOM_STEP;
      setImageTransform();
    }
  }

  function zoomOut() {
    if (scale > MIN_SCALE) {
      scale -= ZOOM_STEP;
      setImageTransform();
    }
  }

  function resetZoom() {
    scale = 1;
    setImageTransform();
  }

  zoomInBtn.addEventListener('click', zoomIn);
  zoomOutBtn.addEventListener('click', zoomOut);
  resetZoomBtn.addEventListener('click', resetZoom);

  let isDragging = false;
  let startX, startY, scrollLeft, scrollTop;

  imageContainer.addEventListener('mousedown', (e) => {
    isDragging = true;
    startX = e.pageX - imageContainer.offsetLeft;
    startY = e.pageY - imageContainer.offsetTop;
    scrollLeft = imageContainer.scrollLeft;
    scrollTop = imageContainer.scrollTop;
  });

  imageContainer.addEventListener('mouseleave', () => {
    isDragging = false;
  });

  imageContainer.addEventListener('mouseup', () => {
    isDragging = false;
  });

  imageContainer.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    e.preventDefault();
    const x = e.pageX - imageContainer.offsetLeft;
    const y = e.pageY - imageContainer.offsetTop;
    const walkX = (x - startX) * 2;
    const walkY = (y - startY) * 2;
    imageContainer.scrollLeft = scrollLeft - walkX;
    imageContainer.scrollTop = scrollTop - walkY;
  });
</script>
{% endblock %}


********************************************************************************

File: templates\document-list.html
********************************************************************************

<!-- templates/document-list.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document List</title>
</head>
<body>
    <h1>Document List</h1>

    <ul id="documentList">
    {% for document in documents %}
        <li>
            <a href="{{ url_for('document_detail', doc_id=document['_id']) }}" target="_blank" rel="noopener noreferrer" class="document-link">{{ document.get('filename', 'Untitled Document') }}</a>
        </li>
    {% endfor %}
    </ul>
</body>
</html>


********************************************************************************

File: templates\error.html
********************************************************************************

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Error</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <h1>Error</h1>
    <p>{{ message }}</p>
    <a href="{{ url_for('index') }}">Return to Home</a>
</body>
</html>


********************************************************************************

File: templates\index.html
********************************************************************************

<!-- templates/index.html -->

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Historical Document Reader</title>
        <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Open+Sans&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    </head>
    <body>
    <div class="container">
        <h1 class="mt-4">Historical Document Reader</h1>
        <nav>
            <ul>
                <li><a href="{{ url_for('index') }}">Home</a></li>
                <li><a href="{{ url_for('search_terms') }}">Search Terms</a></li>
                <li><a href="{{ url_for('database_info') }}">Database Info</a></li>
                <li><a href="{{ url_for('settings') }}">Settings</a></li>
                {% if 'logged_in' in session %}
                    <li><a href="{{ url_for('logout') }}">Logout</a></li>
                {% else %}
                    <li><a href="{{ url_for('login') }}">Login</a></li>
                {% endif %}
            </ul>
        </nav>

        <form id="searchForm" method="POST" action="{{ url_for('search') }}">
            <div id="searchFields">
                {% for i in range(1, num_search_fields + 1) %}
                <div class="search-field">
                    <label for="field{{ i }}">Field:</label>
                    <select name="field{{ i }}" id="field{{ i }}">
                        {% for field in field_structure|dictsort %}
                            <option value="{{ field[0] }}">{{ field[0] }}</option>
                        {% endfor %}
                    </select>
                    <label for="operator{{ i }}">Operator:</label>
                    <select name="operator{{ i }}" id="operator{{ i }}">
                        <option value="AND">AND</option>
                        <option value="OR">OR</option>
                        <option value="NOT">NOT</option>
                    </select>
                    <label for="searchTerm{{ i }}">Search Term:</label>
                    <input type="text" name="searchTerm{{ i }}" id="searchTerm{{ i }}" placeholder="Enter search term">
                </div>
                {% endfor %}
            </div>
            <button type="submit" id="searchButton">Search</button>
        </form>

        <!-- Loading Indicator -->
        <div id="loadingIndicator" style="display: none;">
            <p>Loading... Please wait.</p>
            <div class="spinner"></div>
        </div>

        <!-- Total Results Display -->
        <div id="totalResults" class="mt-4"></div>
        <div id="results" class="mt-4">
            <!-- The table will be dynamically inserted here -->
        </div>
    </div>

    <!-- Include jQuery -->
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <!-- Include your custom script -->
    <script src="{{ url_for('static', filename='script.js') }}"></script>
</body>
</html>


********************************************************************************

File: templates\search-terms.html
********************************************************************************

<!-- File: templates/search-terms.html -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Search Terms</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <!-- Include DataTables CSS -->
    <link rel="stylesheet" href="https://cdn.datatables.net/1.10.21/css/jquery.dataTables.css">
    <style>
        #loadingIndicator {
            display: none;
            text-align: center;
            margin-top: 20px;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Search Terms</h1>
        <nav>
            <ul>
                <li><a href="{{ url_for('index') }}">Home</a></li>
                <li><a href="{{ url_for('search_terms') }}">Search Terms</a></li>
                <li><a href="{{ url_for('database_info') }}">Database Info</a></li>
                <li><a href="{{ url_for('settings') }}">Settings</a></li>
            </ul>
        </nav>
        <div>
            <label for="fieldSelect">Select Field:</label>
            <select id="fieldSelect">
                {% for field in field_structure|dictsort %}
                    <option value="{{ field[0] }}">{{ field[0] }}</option>
                {% endfor %}
            </select>
        </div>
        <div id="tableInfo">
            <p>Number of unique terms: <span id="uniqueTerms">{{ unique_terms }}</span></p>
            <p>Total number of records: <span id="totalRecords">{{ total_records }}</span></p>
        </div>
        <div id="loadingIndicator">
            <div class="spinner"></div>
            <p>Loading data...</p>
        </div>
        <table id="termsTable">
            <thead>
                <tr>
                    <th>Term</th>
                    <th>Count</th>
                </tr>
            </thead>
            <tbody>
                {% for term in terms %}
                <tr>
                    <td>{{ term.term }}</td>
                    <td>{{ term.count }}</td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
    <!-- Include jQuery and DataTables JS -->
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://cdn.datatables.net/1.10.21/js/jquery.dataTables.js"></script>
    <script>
        $(document).ready(function() {
            var table = $('#termsTable').DataTable({
                "pageLength": 25,
                "order": [[ 1, "desc" ]]
            });

            function updateTableInfo(data) {
                $('#uniqueTerms').text(data.unique_terms);
                $('#totalRecords').text(data.total_records);
            }

            $('#fieldSelect').on('change', function() {
                var selectedField = $(this).val();
                $('#loadingIndicator').show();

                $.ajax({
                    url: '/search-terms',
                    data: { field: selectedField },
                    success: function(data) {
                        if (data.error) {
                            alert(data.error);
                        } else {
                            table.clear();
                            data.terms.forEach(function(term) {
                                table.row.add([term.term, term.count]);
                            });
                            table.draw();
                            updateTableInfo(data);
                        }
                        $('#loadingIndicator').hide();
                    },
                    error: function() {
                        alert('Error fetching data. Please try again.');
                        $('#loadingIndicator').hide();
                    }
                });
            });

            // Trigger change event on page load to fetch initial data
            $('#fieldSelect').trigger('change');
        });
    </script>
</body>
</html>


********************************************************************************

File: templates\database-info.html
********************************************************************************

<!-- templates/database-info.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Database Information</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div class="container">
        <h1>Database Information</h1>
        <nav>
            <ul>
                <li><a href="{{ url_for('index') }}">Home</a></li>
                <li><a href="{{ url_for('search_terms') }}">Search Terms</a></li>
                <li><a href="{{ url_for('database_info') }}">Database Info</a></li>
                <li><a href="{{ url_for('settings') }}">Settings</a></li>
            </ul>
        </nav>
        <table>
            <thead>
                <tr>
                    <th>Field Name</th>
                    <th>Number of Records</th>
                </tr>
            </thead>
            <tbody>
                {% for field in collection_info %}
                <tr>
                    <td>{{ field.name }}</td>
                    <td>{{ field.count }}</td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
</body>
</html>


********************************************************************************

File: templates\settings.html
********************************************************************************

<!-- File: templates/settings.html -->

{% extends "base.html" %}

{% block content %}
<div class="container">
    <h1>Settings</h1>
    <form method="POST">
        <h2>Fonts</h2>
        <label for="fonts_main">Main Font:</label>
        <input type="text" id="fonts_main" name="fonts[main]" value="{{ config['fonts']['main'] }}"><br>
        <label for="fonts_headers">Headers Font:</label>
        <input type="text" id="fonts_headers" name="fonts[headers]" value="{{ config['fonts']['headers'] }}"><br>

        <h2>Sizes</h2>
        <label for="sizes_base">Base Size:</label>
        <input type="text" id="sizes_base" name="sizes[base]" value="{{ config['sizes']['base'] }}"><br>
        <label for="sizes_h1">H1 Size:</label>
        <input type="text" id="sizes_h1" name="sizes[h1]" value="{{ config['sizes']['h1'] }}"><br>
        <label for="sizes_h2">H2 Size:</label>
        <input type="text" id="sizes_h2" name="sizes[h2]" value="{{ config['sizes']['h2'] }}"><br>
        <label for="sizes_h3">H3 Size:</label>
        <input type="text" id="sizes_h3" name="sizes[h3]" value="{{ config['sizes']['h3'] }}"><br>

        <h2>Colors</h2>
        <label for="colors_primary">Primary Color:</label>
        <input type="color" id="colors_primary" name="colors[primary]" value="{{ config['colors']['primary'] }}"><br>
        <label for="colors_secondary">Secondary Color:</label>
        <input type="color" id="colors_secondary" name="colors[secondary]" value="{{ config['colors']['secondary'] }}"><br>
        <label for="colors_background">Background Color:</label>
        <input type="color" id="colors_background" name="colors[background]" value="{{ config['colors']['background'] }}"><br>
        <label for="colors_text">Text Color:</label>
        <input type="color" id="colors_text" name="colors[text]" value="{{ config['colors']['text'] }}"><br>

        <h2>Spacing</h2>
        <label for="spacing_small">Small Spacing:</label>
        <input type="text" id="spacing_small" name="spacing[small]" value="{{ config['spacing']['small'] }}"><br>
        <label for="spacing_medium">Medium Spacing:</label>
        <input type="text" id="spacing_medium" name="spacing[medium]" value="{{ config['spacing']['medium'] }}"><br>
        <label for="spacing_large">Large Spacing:</label>
        <input type="text" id="spacing_large" name="spacing[large]" value="{{ config['spacing']['large'] }}"><br>

        <button type="submit">Save Settings</button>
    </form>
</div>
<script>
    // Convert nested objects to JSON strings before form submission
    document.querySelector('form').addEventListener('submit', function(e) {
        ['fonts', 'sizes', 'colors', 'spacing'].forEach(function(key) {
            var inputs = document.querySelectorAll(`[name^="${key}\\["]`);
            var obj = {};
            inputs.forEach(function(input) {
                var prop = input.name.match(/\[(.*?)\]/)[1];
                obj[prop] = input.value;
            });
            var hiddenInput = document.createElement('input');
            hiddenInput.type = 'hidden';
            hiddenInput.name = key;
            hiddenInput.value = JSON.stringify(obj);
            this.appendChild(hiddenInput);
        }, this);
    });
</script>
{% endblock %}


********************************************************************************

File: templates\base.html
********************************************************************************

<!-- templates/base.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{% block title %}Historical Document Reader{% endblock %}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <nav>
        <ul>
            <li><a href="{{ url_for('index') }}">Home</a></li>
            {% if session.get('logged_in') %}
                <li><a href="{{ url_for('logout') }}">Logout</a></li>
            {% else %}
                <li><a href="{{ url_for('login') }}">Login</a></li>
            {% endif %}
            <li><a href="{{ url_for('search_terms') }}">Search Terms</a></li>
            <li><a href="{{ url_for('database_info') }}">Database Info</a></li>
            <li><a href="{{ url_for('settings') }}">Settings</a></li>
        </ul>
    </nav>
    
    {% with messages = get_flashed_messages() %}
        {% if messages %}
            <ul class="flashes">
                {% for message in messages %}
                    <li>{{ message }}</li>
                {% endfor %}
            </ul>
        {% endif %}
    {% endwith %}
    
    {% block content %}{% endblock %}
</body>
</html>


********************************************************************************

File: templates\login.html
********************************************************************************

<!-- File: templates/login.html -->
<!-- Created: 2024-08-12 11:00 -->

{% extends "base.html" %}

{% block content %}
    <h1>Login</h1>
    
    {% with messages = get_flashed_messages() %}
        {% if messages %}
            <ul class="flashes">
                {% for message in messages %}
                    <li>{{ message }}</li>
                {% endfor %}
            </ul>
        {% endif %}
    {% endwith %}
    
    <form method="post">
        <label for="password">Password:</label>
        <input type="password" id="password" name="password" required>
        <br><br>
        
        <label for="captcha">CAPTCHA: What is {{ captcha_num1 }} + {{ captcha_num2 }}?</label>
        <input type="number" id="captcha" name="captcha" required>
        <input type="hidden" name="captcha_answer" value="{{ captcha_answer }}">
        <br><br>
        
        <input type="submit" value="Login">
    </form>
{% endblock %}

********************************************************************************

