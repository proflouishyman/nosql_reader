Project File Combination
Generated on: 2024-09-20 15:31:56.321277

Total files: 24
File type counts:
  .py: 8
  .md: 1
  .js: 1
  .css: 1
  .html: 9

File Structure:
nosql_reader/
    app.py
    generate_password.py
    readme.md
    requirements.txt
    routes.py
    combined_project_files.txt
    data_processing.py
    database_setup.py
    json_validator.py
    json_validator_multi.py
    config.json
    secret_key.txt
    models.py
    static/
        script.js
        style.css
    templates/
        document-detail.html
        document-list.html
        error.html
        index.html
        search-terms.html
        database-info.html
        settings.html
        base.html
        login.html

********************************************************************************

File: app.py
********************************************************************************

# File: app.py
# Path: railroad_documents_project/app.py

import os
import json
from flask import Flask
from flask_caching import Cache
from flask_session import Session
from database_setup import client, db, documents, field_structure
import logging
from logging.handlers import RotatingFileHandler



app = Flask(__name__)


# Configure cache (optional, for performance enhancements)
cache = Cache(app, config={'CACHE_TYPE': 'simple'})

# Setup console logging
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.DEBUG)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
console_handler.setFormatter(formatter)

# Add the console handler to the app's logger
app.logger.addHandler(console_handler)

# # Setup file-based logging
# if not app.debug:
#     file_handler = RotatingFileHandler('logs/app.log', maxBytes=10240, backupCount=10)
#     file_handler.setLevel(logging.DEBUG)
#     formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
#     file_handler.setFormatter(formatter)
#     app.logger.addHandler(file_handler)

app.logger.setLevel(logging.DEBUG)


# Load configuration
config_path = os.path.join(os.path.dirname(__file__), 'config.json')
with open(config_path) as config_file:
    config = json.load(config_file)

# Add config to app config
app.config['UI_CONFIG'] = config

# Print out the template folder path for debugging
print(f"Template folder path: {app.template_folder}")

# Session configuration
app.config['SESSION_TYPE'] = 'filesystem'
app.config['SESSION_PERMANENT'] = False
app.config['SESSION_USE_SIGNER'] = True
app.config['SESSION_KEY_PREFIX'] = 'historical_document_reader'

def get_secret_key():
    secret_file = os.path.join(app.root_path, 'secret_key.txt')
    if os.path.exists(secret_file):
        with open(secret_file, 'r') as f:
            return f.read().strip()
    else:
        import secrets
        generated_key = secrets.token_hex(16)
        with open(secret_file, 'w') as f:
            f.write(generated_key)
        return generated_key

# Set the secret key
app.secret_key = get_secret_key()

# Initialize extensions
cache = Cache(config={'CACHE_TYPE': 'simple'})
cache.init_app(app)
Session(app)

def load_config():
    """
    Load the configuration from the JSON file.
    This function is called on each request to allow for dynamic UI configuration.
    """
    config_path = os.path.join(os.path.dirname(__file__), 'config.json')
    with open(config_path) as config_file:
        return json.load(config_file)

def get_field_structure():
    """
    Load the field structure from the MongoDB collection.
    """
    structure = field_structure.find_one({"_id": "current_structure"})
    return structure['structure'] if structure else {}

@app.context_processor
def inject_ui_config():
    """
    Inject the UI configuration and field structure into all templates.
    This allows for dynamic UI customization without needing to pass the config to each template.
    """
    app.config['UI_CONFIG'] = load_config()
    field_struct = get_field_structure()
    return dict(ui_config=app.config['UI_CONFIG'], field_structure=field_struct)

# Import routes after initializing app to avoid circular imports
from routes import *

if __name__ == '__main__':
    # Run the app
    app.run(debug=True)


********************************************************************************

File: generate_password.py
********************************************************************************

from werkzeug.security import generate_password_hash

actual_password = 'loulou'
method = 'pbkdf2:sha256:260000'

password_hash = generate_password_hash(actual_password, method=method)
print(password_hash)



********************************************************************************

File: readme.md
********************************************************************************

# Historical Document Reader

## Description
The Historical Document Reader is a Flask-based web application designed to manage, search, and display historical documents stored in a MongoDB database. It provides an intuitive interface for researchers and historians to access and analyze digitized historical records.

## Features

### Document Management
- Data ingestion from JSON files
- Dynamic field structure discovery and adaptation
- Storage of documents in MongoDB

### Search Functionality
- Advanced search with multiple fields and logical operators (AND, OR, NOT)
- Infinite scrolling for search results
- AJAX-based search for improved responsiveness
- Prefetching of next page results for smoother scrolling

### Document Viewing
- Detailed view of individual documents
- Image viewing with zoom and pan capabilities for document images
- Navigation between documents in search results

### Data Analysis
- Search terms analysis with word and phrase frequency
- Database structure information display

### User Interface
- Customizable UI settings (fonts, colors, spacing)
- Responsive design for various screen sizes

### Data Export
- Export search results to CSV

### Security
- Basic authentication system
- CAPTCHA implementation to prevent automated login attempts

### Additional Features
- Error handling and user feedback
- Logging system for debugging and monitoring

## File Structure
```
historical_document_reader/
│
├── app.py
├── routes.py
├── models.py
├── database_setup.py
├── data_processing.py
├── json_validator.py
├── json_validator_multi.py
├── generate_password.py
├── requirements.txt
├── config.json
├── secret_key.txt
├── README.md
│
├── static/
│   ├── script.js
│   └── style.css
│
└── templates/
    ├── base.html
    ├── index.html
    ├── document-detail.html
    ├── document-list.html
    ├── search-terms.html
    ├── database-info.html
    ├── settings.html
    ├── login.html
    └── error.html
```

## Installation and Setup

1. Clone the repository:
   ```
   git clone https://github.com/your-username/historical-document-reader.git
   ```

2. Navigate to the project directory:
   ```
   cd historical-document-reader
   ```

3. Install the required dependencies:
   ```
   pip install -r requirements.txt
   ```

4. Set up MongoDB:
   - Install MongoDB if you haven't already.
   - Start the MongoDB service.
   - Update the connection string in `database_setup.py` if necessary:
     ```python
     client = MongoClient('mongodb://localhost:27017/')
     ```

5. Initialize the database structure:
   ```
   python database_setup.py
   ```
   This script will create necessary indexes and initialize the field structure.

6. Prepare your JSON data:
   - Ensure your historical document data is in JSON format.
   - If your data is in .txt files, use the JSON validator to convert and validate them:
     ```
     python json_validator.py
     ```
   - This script will process .txt files in the specified directory, convert them to valid JSON, and save them with a .json extension.

7. Ingest data into the database:
   - Update the `data_directory` path in `data_processing.py` to point to your JSON files:
     ```python
     data_directory = r'path/to/your/json/files'
     ```
   - Run the data processing script:
     ```
     python data_processing.py
     ```
   - This script will read the JSON files, insert them into the MongoDB database, update the field structure, and compute unique terms for search functionality.

8. Generate a password for admin access (optional):
   ```
   python generate_password.py
   ```
   - This will generate a hashed password. Copy the output and update the `ADMIN_PASSWORD_HASH` in `routes.py`.

9. Run the application:
   ```
   python app.py
   ```

## Usage

1. Access the application through a web browser at `http://localhost:5000`.

2. If you set up admin access, log in using the password you generated.

3. Use the search interface to find documents:
   - Select fields from the dropdown menus.
   - Choose operators (AND, OR, NOT) to combine search criteria.
   - Enter search terms and click "Search".

4. View search results:
   - Click on a document title to view its details.
   - Use infinite scrolling to load more results.

5. Analyze search terms:
   - Navigate to the "Search Terms" page.
   - Select a field to see word and phrase frequencies.

6. View database information:
   - Go to the "Database Info" page to see the structure and record counts.

7. Customize the interface:
   - Use the "Settings" page to adjust fonts, colors, and spacing.

8. Export results:
   - Use the "Export to CSV" button to download search results.

## Maintenance and Updates

- To add new documents, place their JSON files in the data directory and run `data_processing.py` again.
- If the structure of your documents changes, the system will automatically adapt when you process new files.
- Regularly backup your MongoDB database to prevent data loss.

## Troubleshooting

- If you encounter issues with data processing, check the JSON format of your files and ensure they are valid.
- For database connection issues, verify your MongoDB service is running and the connection string is correct.
- Check the application logs for any error messages or unexpected behavior.

## Python Files Description

Here's a breakdown of the main Python files in the project and their functions:

### `app.py`
- Main application file
- Initializes the Flask app and configures it
- Sets up caching, logging, and session management
- Loads the UI configuration
- Defines context processors for injecting data into templates

### `routes.py`
- Contains all the route handlers for different endpoints
- Implements the main functionality of the web application:
  - Search
  - Document viewing
  - Database information display
  - Search terms analysis
  - User authentication
  - Settings management
  - CSV export

### `database_setup.py`
- Establishes connection to MongoDB
- Defines functions for CRUD operations on documents
- Implements dynamic field structure discovery and updates
- Creates necessary indexes for performance optimization

### `data_processing.py`
- Handles the ingestion of JSON files into the MongoDB database
- Processes documents to extract and store unique terms
- Updates the field structure based on ingested documents
- Implements multiprocessing for faster data ingestion

### `json_validator.py`
- Validates and cleans JSON files
- Converts .txt files to proper JSON format
- Implements multiprocessing for efficient file processing

### `json_validator_multi.py`
- Similar to `json_validator.py` but optimized for handling multiple files
- Uses multiprocessing to speed up the validation and conversion process

### `generate_password.py`
- Utility script to generate a hashed password for admin access
- Uses Werkzeug's password hashing function

### `models.py`
- This file is currently not in use as the project uses a NoSQL database
- Kept for potential future use if SQL models are needed

## Contributing

Contributions to the Historical Document Reader are welcome. Please follow these steps:

1. Fork the repository.
2. Create a new branch for your feature or bug fix.
3. Make your changes and commit them with descriptive commit messages.
4. Push your changes to your fork.
5. Submit a pull request to the main repository.

## License

[Insert your chosen license here]

## Contact

[Your Name or Organization]
[Contact Information]



********************************************************************************

File: routes.py
********************************************************************************

# File: routes.py
# Path: routes.py

from flask import request, jsonify, render_template, redirect, url_for, flash, session, abort, Response, send_file
from functools import wraps
from app import app, cache
from database_setup import (
    documents,
    find_document_by_id,
    find_documents,
    insert_document,
    update_document,
    delete_document,
    get_field_structure,
    unique_terms_collection
)
from bson import ObjectId
from werkzeug.security import generate_password_hash, check_password_hash
import math
import json
import re
import logging
import time
from datetime import datetime, timedelta
import random
import csv
from io import StringIO
from logging.handlers import RotatingFileHandler
import os

app.logger.setLevel(logging.DEBUG)

# Hashed password (generate this using generate_password_hash('your_actual_password'))
ADMIN_PASSWORD_HASH = 'pbkdf2:sha256:260000$uxZ1Fkjt9WQCHwuN$ca37dfb41ebc26b19daf24885ebcd09f607cab85f92dcab13625627fd9ee902a'

# Login attempt tracking
MAX_ATTEMPTS = 5
LOCKOUT_TIME = 15 * 60  # 15 minutes in seconds
login_attempts = {}

def is_locked_out(ip):
    if ip in login_attempts:
        attempts, last_attempt_time = login_attempts[ip]
        if attempts >= MAX_ATTEMPTS:
            if datetime.now() - last_attempt_time < timedelta(seconds=LOCKOUT_TIME):
                return True
            else:
                login_attempts[ip] = (0, datetime.now())
    return False

def update_login_attempts(ip, success):
    if ip in login_attempts:
        attempts, _ = login_attempts[ip]
        if success:
            login_attempts[ip] = (0, datetime.now())
        else:
            login_attempts[ip] = (attempts + 1, datetime.now())
    else:
        login_attempts[ip] = (0, datetime.now()) if success else (1, datetime.now())

# Login required decorator
def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'logged_in' not in session:
            return redirect(url_for('login', next=request.url))
        return f(*args, **kwargs)
    return decorated_function

@app.route('/')
# @login_required
def index():
    app.logger.info('Handling request to index')
    num_search_fields = 3  # Number of search fields to display
    field_structure = get_field_structure()
    return render_template('index.html', num_search_fields=num_search_fields, field_structure=field_structure)

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        ip = request.remote_addr

        if is_locked_out(ip):
            flash('Too many failed attempts. Please try again later.')
            return render_template('login.html')

        # Verify CAPTCHA
        user_captcha = request.form.get('captcha')
        correct_captcha = request.form.get('captcha_answer')
        if user_captcha != correct_captcha:
            flash('Incorrect CAPTCHA')
            return redirect(url_for('login'))

        if check_password_hash(ADMIN_PASSWORD_HASH, request.form['password']):
            session['logged_in'] = True
            update_login_attempts(ip, success=True)
            flash('You were successfully logged in')
            next_page = request.args.get('next')
            return redirect(next_page or url_for('index'))
        else:
            update_login_attempts(ip, success=False)
            time.sleep(2)  # Add a delay after failed attempt
            flash('Invalid password')

    # Generate CAPTCHA for GET requests
    captcha_num1 = random.randint(1, 10)
    captcha_num2 = random.randint(1, 10)
    captcha_answer = str(captcha_num1 + captcha_num2)

    return render_template('login.html', captcha_num1=captcha_num1, captcha_num2=captcha_num2, captcha_answer=captcha_answer)

@app.route('/logout')
def logout():
    session.pop('logged_in', None)
    flash('You were logged out')
    return redirect(url_for('index'))

@app.route('/search', methods=['POST'])
# @login_required
def search():
    try:
        data = request.get_json()
        app.logger.debug(f"Received search request: {data}")

        page = int(data.get('page', 1))
        per_page = int(data.get('per_page', 50))

        query = build_query(data)
        app.logger.debug(f"Constructed MongoDB query: {query}")

        total_count = documents.count_documents(query)
        search_results = list(documents.find(query).skip((page - 1) * per_page).limit(per_page))

        for doc in search_results:
            doc['_id'] = str(doc['_id'])

        total_pages = math.ceil(total_count / per_page) if per_page else 1

        app.logger.debug(f"Found {total_count} documents, returning page {page} of {total_pages}")

        return jsonify({
            "documents": search_results,
            "total_count": total_count,
            "current_page": page,
            "total_pages": total_pages,
            "per_page": per_page
        })

    except Exception as e:
        app.logger.error(f"An error occurred during search: {str(e)}", exc_info=True)
        return jsonify({"error": "An internal error occurred"}), 500

def build_query(data):
    query = {}
    criteria_list = []

    app.logger.debug(f"Building query from search data: {data}")

    for i in range(1, 4):
        field = data.get(f'field{i}')
        search_term = data.get(f'searchTerm{i}')
        operator = data.get(f'operator{i}')

        if field and search_term:
            condition = {}
            if operator == 'NOT':
                condition[field] = {'$not': {'$regex': re.escape(search_term), '$options': 'i'}}
            else:
                condition[field] = {'$regex': re.escape(search_term), '$options': 'i'}
            
            criteria_list.append((operator, condition))
            app.logger.debug(f"Processed field {field} with search term '{search_term}' and operator '{operator}'")

    if criteria_list:
        and_conditions = []
        or_conditions = []

        for operator, condition in criteria_list:
            if operator == 'AND' or operator == 'NOT':
                and_conditions.append(condition)
            elif operator == 'OR':
                or_conditions.append(condition)

        if and_conditions:
            query['$and'] = and_conditions

        if or_conditions:
            if '$or' not in query:
                query['$or'] = or_conditions
            else:
                query['$or'].extend(or_conditions)

    app.logger.debug(f"Final query: {query}")
    return query

@app.route('/document/<string:doc_id>')
# @login_required
def document_detail(doc_id):
    try:
        document = find_document_by_id(doc_id)
        if not document:
            abort(404)

        document['_id'] = str(document['_id'])

        prev_doc = documents.find_one({'_id': {'$lt': ObjectId(doc_id)}}, sort=[('_id', -1)])
        next_doc = documents.find_one({'_id': {'$gt': ObjectId(doc_id)}}, sort=[('_id', 1)])

        prev_id = str(prev_doc['_id']) if prev_doc else None
        next_id = str(next_doc['_id']) if next_doc else None

        return render_template('document-detail.html', document=document, prev_id=prev_id, next_id=next_id)
    except Exception as e:
        app.logger.error(f"Error in document_detail: {str(e)}")
        abort(500)



@app.route('/search-terms', methods=['GET'])
# @login_required
def search_terms():
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        # Handle AJAX request
        field = request.args.get('field')
        app.logger.debug(f"AJAX request for field: {field}")
        if not field:
            return jsonify({"error": "No field specified"}), 400

        # Fetch unique terms for the specified field from unique_terms_collection
        unique_terms_doc = unique_terms_collection.find_one({"field": field})
        if not unique_terms_doc:
            app.logger.debug(f"No terms found for field '{field}'.")
            return jsonify({
                "words": [],
                "phrases": [],
                "unique_words": 0,
                "unique_phrases": 0,
                "total_records": documents.count_documents({}),
                "message": f"No terms found for field '{field}'."
            }), 200  # Changed status to 200

        words = unique_terms_doc.get('words', {})
        phrases = unique_terms_doc.get('phrases', {})
        unique_words_count = len(words)
        unique_phrases_count = len(phrases)
        total_records = documents.count_documents({})

        # Convert words and phrases to lists of dictionaries
        words_list = [{'word': word, 'count': count} for word, count in sorted(words.items())]
        phrases_list = [{'phrase': phrase, 'count': count} for phrase, count in sorted(phrases.items())]

        data = {
            'words': words_list,
            'phrases': phrases_list,
            'unique_words': unique_words_count,
            'unique_phrases': unique_phrases_count,
            'total_records': total_records
        }

        return jsonify(data)
    else:
        # Render the HTML template
        field_structure = get_field_structure()
        return render_template('search-terms.html', field_structure=field_structure)

    

@app.route('/database-info')
# @login_required
def database_info():
    field_struct = get_field_structure()
    collection_info = []

    def count_documents_with_field(field_path):
        count = documents.count_documents({field_path: {'$exists': True}})
        return count

    def traverse_structure(structure, current_path=''):
        for field, value in structure.items():
            path = f"{current_path}.{field}" if current_path else field
            if isinstance(value, dict):
                traverse_structure(value, current_path=path)
            else:
                count = count_documents_with_field(path)
                collection_info.append({
                    'name': path,
                    'count': count
                })

    traverse_structure(field_struct)

    return render_template('database-info.html', collection_info=collection_info)

@app.route('/settings', methods=['GET', 'POST'])
# @login_required
def settings():
    config_path = os.path.join(os.path.dirname(__file__), 'config.json')

    if request.method == 'POST':
        new_config = request.form.to_dict()

        for key in ['fonts', 'sizes', 'colors', 'spacing']:
            if key in new_config:
                try:
                    new_config[key] = json.loads(new_config[key])
                except json.JSONDecodeError:
                    flash(f"Invalid JSON format for {key}.", 'danger')
                    return redirect(url_for('settings'))

        try:
            with open(config_path, 'w') as config_file:
                json.dump(new_config, config_file, indent=4)
            app.config['UI_CONFIG'] = new_config
            flash('Settings updated successfully', 'success')
        except Exception as e:
            app.logger.error(f"Error updating settings: {str(e)}")
            flash('Failed to update settings.', 'danger')
        return redirect(url_for('settings'))

    try:
        if os.path.exists(config_path):
            with open(config_path) as config_file:
                config = json.load(config_file)
        else:
            config = {}
    except json.JSONDecodeError:
        config = {}
        flash('Configuration file is corrupted. Using default settings.', 'warning')

    return render_template('settings.html', config=config)



# consider streaming if it ends up being thousands of documents
@app.route('/export_selected_csv', methods=['POST'])
#@login_required
def export_selected_csv():
    try:
        data = request.get_json()
        document_ids = data.get('document_ids', [])
        if not document_ids:
            return jsonify({"error": "No document IDs provided"}), 400

        # Convert string IDs to ObjectIds, handle invalid IDs
        valid_ids = []
        for doc_id in document_ids:
            try:
                valid_ids.append(ObjectId(doc_id))
            except Exception as e:
                app.logger.warning(f"Invalid document ID: {doc_id}")

        if not valid_ids:
            return jsonify({"error": "No valid document IDs provided"}), 400

        # Check if any documents exist with the provided IDs
        count = documents.count_documents({"_id": {"$in": valid_ids}})
        if count == 0:
            return jsonify({"error": "No documents found for the provided IDs."}), 404

        # Retrieve the documents
        documents_cursor = documents.find({"_id": {"$in": valid_ids}})

        # Create CSV
        output = StringIO()
        writer = csv.writer(output)
        writer.writerow(['filename', 'OCR', 'original_json'])  # Header row

        for doc in documents_cursor:
            filename = doc.get('filename', 'N/A')
            ocr = doc.get('summary', 'N/A')  # Adjust field as necessary
            original_json = json.dumps(doc, default=str)  # Convert ObjectId to string if necessary
            writer.writerow([filename, ocr, original_json])

        # Prepare CSV for download
        output.seek(0)
        return Response(
            output.getvalue(),
            mimetype='text/csv',
            headers={'Content-Disposition': 'attachment; filename=selected_documents.csv'}
        )

    except Exception as e:
        app.logger.error(f"Error exporting selected CSV: {str(e)}", exc_info=True)
        return jsonify({"error": "An internal error occurred"}), 500

@app.errorhandler(404)
def not_found_error(error):
    return render_template('error.html', message='Page not found'), 404

@app.errorhandler(500)
def internal_error(error):
    return render_template('error.html', message='An unexpected error has occurred'), 500


********************************************************************************

File: data_processing.py
********************************************************************************


import os
import json
from database_setup import (
    insert_document,
    update_field_structure,
    unique_terms_collection,
    documents
)
from multiprocessing import Pool, cpu_count
from tqdm import tqdm
import time
from pymongo import MongoClient
import re
import logging

# Function to initialize a new MongoDB connection for each process
def init_db():
    global documents
    client = MongoClient('mongodb://localhost:27017/')
    db = client['railroad_documents']
    documents = db['documents']

def load_json_file(file_path):
    """
    Load a JSON file and return its content as a dictionary.
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            return json.load(file)
    except json.JSONDecodeError as e:
        print(f"Error decoding JSON in {file_path}: {str(e)}")
        return None
    except Exception as e:
        print(f"Error reading file {file_path}: {str(e)}")
        return None

def process_file(file_path):
    """
    Process a single JSON file: load it, add filename, update field structure,
    and collect unique words and phrases.
    """
    filename = os.path.basename(file_path)
    logging.debug(f"Processing file: {filename}")
    json_data = load_json_file(file_path)
    if json_data:
        # Add filename as a field if it's not already present
        json_data.setdefault('filename', filename)
        try:
            update_field_structure(json_data)  # Update field structure for each new document
            logging.debug(f"Updated field structure for {filename}")
        except Exception as e:
            logging.error(f"Error updating field structure for {filename}: {e}")
            return None

        # Insert document into the database
        try:
            insert_document(json_data)
            logging.debug(f"Inserted document: {filename}")
        except Exception as e:
            logging.error(f"Error inserting document {filename}: {e}")
            return None

        # Collect unique words and phrases by tokenizing
        unique_terms = {}
        for field, value in json_data.items():
            if isinstance(value, str):
                words = re.findall(r'\w+', value.lower())
                phrases = [' '.join(pair) for pair in zip(words, words[1:])]
                if words:
                    unique_terms.setdefault(field, {'words': {}, 'phrases': {}})
                    # Count words
                    for word in words:
                        unique_terms[field]['words'][word] = unique_terms[field]['words'].get(word, 0) + 1
                    # Count phrases
                    for phrase in phrases:
                        unique_terms[field]['phrases'][phrase] = unique_terms[field]['phrases'].get(phrase, 0) + 1
            elif isinstance(value, list):
                for item in value:
                    if isinstance(item, str):
                        words = re.findall(r'\w+', item.lower())
                        phrases = [' '.join(pair) for pair in zip(words, words[1:])]
                        if words:
                            unique_terms.setdefault(field, {'words': {}, 'phrases': {}})
                            # Count words
                            for word in words:
                                unique_terms[field]['words'][word] = unique_terms[field]['words'].get(word, 0) + 1
                            # Count phrases
                            for phrase in phrases:
                                unique_terms[field]['phrases'][phrase] = unique_terms[field]['phrases'].get(phrase, 0) + 1
            # Add more conditions if fields can have other types

        # Filter out words and phrases with count < 2
        for field in unique_terms:
            # Filter words
            original_word_count = len(unique_terms[field]['words'])
            unique_terms[field]['words'] = {word: count for word, count in unique_terms[field]['words'].items() if count >= 2}
            filtered_word_count = len(unique_terms[field]['words'])
            logging.debug(f"Filtered words in '{field}': {original_word_count} -> {filtered_word_count}")

            # Filter phrases
            original_phrase_count = len(unique_terms[field]['phrases'])
            unique_terms[field]['phrases'] = {phrase: count for phrase, count in unique_terms[field]['phrases'].items() if count >= 2}
            filtered_phrase_count = len(unique_terms[field]['phrases'])
            logging.debug(f"Filtered phrases in '{field}': {original_phrase_count} -> {filtered_phrase_count}")

        logging.debug(f"Collected unique terms for {filename}")
        return unique_terms

def merge_unique_terms(main_dict, new_dict):
    """
    Merge two unique terms dictionaries.
    Only includes words and phrases with counts >= 2.
    """
    for field, terms in new_dict.items():
        if field not in main_dict:
            main_dict[field] = {'words': {}, 'phrases': {}}
        # Merge words
        for word, count in terms['words'].items():
            main_dict[field]['words'][word] = main_dict[field]['words'].get(word, 0) + count
        # Merge phrases
        for phrase, count in terms['phrases'].items():
            main_dict[field]['phrases'][phrase] = main_dict[field]['phrases'].get(phrase, 0) + count


def save_unique_terms(unique_terms_dict):
    """
    Save the unique terms dictionary to the database.
    Only includes words and phrases with counts >= 2.
    """
    unique_terms_documents = []
    for field, terms in unique_terms_dict.items():
        # Ensure that words and phrases are not empty after filtering
        if terms['words'] or terms['phrases']:
            unique_terms_documents.append({
                "field": field,
                "words": terms['words'],
                "phrases": terms['phrases']
            })
    try:
        unique_terms_collection.delete_many({})
        if unique_terms_documents:
            unique_terms_collection.insert_many(unique_terms_documents)
        logging.debug("Unique terms updated in the database.")
    except Exception as e:
        logging.error(f"Error saving unique terms: {e}")


def process_directory(directory_path):
    """
    Process all JSON files in a directory using multiprocessing:
    delete existing documents, insert new ones, update field structure,
    and compute unique terms.
    """
    # Clear existing data
    print("Clearing existing data...")
    try:
        documents.delete_many({})
        unique_terms_collection.delete_many({})
        from database_setup import field_structure
        field_structure.delete_many({})
        print("Cleared data.")
    except Exception as e:
        print(f"Error clearing data: {e}")

    start_time = time.time()
    files = [os.path.join(directory_path, f) for f in os.listdir(directory_path) if f.endswith('.json')]
    total = len(files)
    final_unique = {}

    with Pool(processes=cpu_count(), initializer=init_db) as pool:
        for result in tqdm(pool.imap(process_file, files), total=total, desc="Processing files"):
            if result:
                merge_unique_terms(final_unique, result)

    # Save unique terms
    save_unique_terms(final_unique)
    duration = time.time() - start_time
    print(f"Processed {total} files in {duration:.2f} seconds.")

if __name__ == "__main__":
    data_directory = r'G:\My Drive\2024-2025\coding\rolls_txt\scratch4\lhyman6\OCR\data\borr\rolls'  # Update as needed
    process_directory(data_directory)

********************************************************************************

File: database_setup.py
********************************************************************************

# File: database_setup.py
# Path: railroad_documents_project/database_setup.py

from pymongo import MongoClient, ASCENDING, DESCENDING
from bson import ObjectId

# Connect to MongoDB
client = MongoClient('mongodb://localhost:27017/')
db = client['railroad_documents']
documents = db['documents']
field_structure = db['field_structure']
unique_terms_collection = db['unique_terms']  # New collection for unique terms

def discover_fields(document):
    """
    Recursively discover fields in a document.
    
    :param document: The document to analyze
    :return: A dictionary representing the field structure
    """
    structure = {}
    for key, value in document.items():
        if isinstance(value, dict):
            structure[key] = discover_fields(value)
        elif isinstance(value, list):
            if value:
                if isinstance(value[0], dict):
                    structure[key] = [discover_fields(value[0])]
                else:
                    structure[key] = [type(value[0]).__name__]
            else:
                structure[key] = []
        else:
            structure[key] = type(value).__name__
    return structure

def merge_structures(existing, new):
    """
    Merge two field structures.
    
    :param existing: The existing field structure
    :param new: The new field structure to merge
    :return: The merged field structure
    """
    for key, value in new.items():
        if key not in existing:
            existing[key] = value
        elif isinstance(value, dict) and isinstance(existing[key], dict):
            merge_structures(existing[key], value)
        elif isinstance(value, list) and isinstance(existing[key], list):
            if value and existing[key]:
                if isinstance(value[0], dict) and isinstance(existing[key][0], dict):
                    merge_structures(existing[key][0], value[0])
    return existing

def update_field_structure(document):
    """
    Update the field structure based on a new document.
    Performs an upsert to avoid duplicate key errors.
    
    :param document: The new document to analyze
    """
    new_structure = discover_fields(document)
    merged_structure = {}

    # Attempt to retrieve the existing structure
    existing_structure = field_structure.find_one({"_id": "current_structure"})
    
    if existing_structure:
        # Merge the new structure with the existing one
        merged_structure = merge_structures(existing_structure['structure'], new_structure)
    else:
        # If no existing structure, use the new structure
        merged_structure = new_structure

    # Perform an upsert operation to update or insert the structure
    field_structure.update_one(
        {"_id": "current_structure"},
        {"$set": {"structure": merged_structure}},
        upsert=True
    )

def get_field_structure():
    """
    Get the current field structure.
    
    :return: The current field structure
    """
    structure = field_structure.find_one({"_id": "current_structure"})
    return structure['structure'] if structure else {}

def insert_document(document_data):
    """
    Insert a new document into the database.
    
    :param document_data: A dictionary containing the document's information
    :return: The ObjectId of the inserted document
    """
    result = documents.insert_one(document_data)
    return result.inserted_id

def find_document_by_id(document_id):
    """
    Find a document by its ObjectId.
    
    :param document_id: The ObjectId of the document
    :return: The document, or None if not found
    """
    return documents.find_one({"_id": ObjectId(document_id)})

def find_documents(query, limit=10):
    """
    Find documents based on a query.
    
    :param query: A dictionary containing the search criteria
    :param limit: Maximum number of results to return (default 10)
    :return: A cursor containing the matching documents
    """
    return documents.find(query).limit(limit)

def update_document(document_id, update_data):
    """
    Update a document's information.
    
    :param document_id: The ObjectId of the document to update
    :param update_data: A dictionary containing the fields to update
    :return: The result of the update operation
    """
    result = documents.update_one({"_id": ObjectId(document_id)}, {"$set": update_data})
    return result.modified_count

def delete_document(document_id):
    """
    Delete a document from the database.
    
    :param document_id: The ObjectId of the document to delete
    :return: The result of the delete operation
    """
    result = documents.delete_one({"_id": ObjectId(document_id)})
    return result.deleted_count

# Create indexes for performance optimization
def create_indexes():
    """
    Create necessary indexes to optimize query performance.
    """
    # Text index for full-text search on all string fields
    documents.create_index([("$**", "text")])

    # Index for unique_terms_collection to optimize retrieval by field
    unique_terms_collection.create_index([("field", ASCENDING)])

    # Additional indexes can be created here as needed
    # Example:
    # documents.create_index([("specific_field", ASCENDING)])

if __name__ == "__main__":
    # Recalculate the field structure based on existing documents
    print("Initializing field structure...")
    field_structure.delete_many({})  # Clear existing field structure
    all_documents = documents.find()
    for doc in all_documents:
        update_field_structure(doc)
    print("Field structure initialized.")

    # Create necessary indexes
    print("Creating indexes...")
    create_indexes()
    print("Indexes created.")


********************************************************************************

File: json_validator.py
********************************************************************************

import os
import json
import re
import multiprocessing
from tqdm import tqdm

def clean_json(json_text):
    # Remove all control characters
    json_text = re.sub(r'[\x00-\x1F\x7F]', '', json_text)

    # Find the index of the first '{' and the last '}'
    start_index = json_text.find('{')
    end_index = json_text.rfind('}')

    # Extract the clean JSON string
    if start_index != -1 and end_index != -1:
        clean_json_text = json_text[start_index:end_index + 1]
        return clean_json_text
    else:
        raise ValueError("Invalid JSON format: Unable to find '{' or '}'.")

def validate_json_file(file_path):
    filename = os.path.basename(file_path)
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            json_content = file.read()

        # Clean the JSON content before validation
        cleaned_json_content = clean_json(json_content)
        cleaned = cleaned_json_content != json_content

        # Validate the cleaned JSON content
        json_data = json.loads(cleaned_json_content)

        # Define the new file path with .json extension
        base_name, _ = os.path.splitext(file_path)
        new_file_path = f"{base_name}.json"

        # Write the validated and cleaned JSON to the new file
        with open(new_file_path, 'w', encoding='utf-8') as file:
            json.dump(json_data, file, indent=4)

        # Remove the original .txt file
        os.remove(file_path)

        return (filename, True, cleaned)
    except Exception as e:
        return (filename, False, str(e))

def validate_and_replace_json_files(source_dir, num_workers):
    # Collect all .txt file paths recursively
    file_paths = []
    for root, dirs, files in os.walk(source_dir):
        for f in files:
            if f.lower().endswith('.txt'):
                file_paths.append(os.path.join(root, f))
    total_files = len(file_paths)

    print(f"Processing {total_files} .txt files with {num_workers} worker processes...")

    # Initialize counters
    cleaned_count = 0
    replaced_count = 0
    invalid_count = 0

    # Use multiprocessing Pool to process files in parallel
    with multiprocessing.Pool(num_workers) as pool:
        # Use imap_unordered for better performance and integrate with tqdm
        results = []
        for result in tqdm(pool.imap_unordered(validate_json_file, file_paths), total=total_files, desc="Validating JSON files"):
            results.append(result)

    # Process the results
    for filename, is_valid, info in results:
        if is_valid:
            if info:
                cleaned_count += 1
            replaced_count += 1
        else:
            invalid_count += 1

    print(f"\nProcessing complete:")
    print(f"Valid JSON files replaced with .json: {replaced_count}")
    print(f"Files cleaned: {cleaned_count}")
    print(f"Invalid or unreadable files remain as .txt: {invalid_count}")

    print("\nDetailed results:")
    for filename, is_valid, info in results:
        if is_valid:
            if info:
                print(f"{filename} was cleaned and replaced with a .json file.")
            else:
                print(f"{filename} is valid and replaced with a .json file.")
        else:
            print(f"{filename} is invalid or unreadable. Remains as .txt. Error: {info}")

if __name__ == "__main__":
    # Specify the source directory
    source_directory = r"G:\My Drive\2024-2025\coding\rolls_txt"

    # Calculate the number of worker processes (3/4 of available CPUs)
    num_cpus = multiprocessing.cpu_count()
    num_workers = max(1, int(num_cpus * 0.75))

    # Start the validation and replacement process
    validate_and_replace_json_files(source_directory, num_workers)


********************************************************************************

File: json_validator_multi.py
********************************************************************************

import os
import json
import re
import multiprocessing
from tqdm import tqdm

def clean_json(json_text):
    # Remove all control characters
    json_text = re.sub(r'[\x00-\x1F\x7F]', '', json_text)

    # Find the index of the first '{' and the last '}'
    start_index = json_text.find('{')
    end_index = json_text.rfind('}')

    # Extract the clean JSON string
    if start_index != -1 and end_index != -1:
        clean_json_text = json_text[start_index:end_index + 1]
        return clean_json_text
    else:
        raise ValueError("Invalid JSON format: Unable to find '{' or '}'.")

def validate_json_file(file_path):
    filename = os.path.basename(file_path)
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            json_content = file.read()

        # Clean the JSON content before validation
        cleaned_json_content = clean_json(json_content)
        cleaned = cleaned_json_content != json_content

        # Validate the cleaned JSON content
        json_data = json.loads(cleaned_json_content)

        # Define the new file path with .json extension
        base_name, _ = os.path.splitext(file_path)
        new_file_path = f"{base_name}.json"

        # Write the validated and cleaned JSON to the new file
        with open(new_file_path, 'w', encoding='utf-8') as file:
            json.dump(json_data, file, indent=4)

        # Remove the original .txt file
        os.remove(file_path)

        return (filename, True, cleaned)
    except Exception as e:
        return (filename, False, str(e))

def validate_and_replace_json_files(source_dir, num_workers):
    # Collect all .txt file paths recursively
    file_paths = []
    for root, dirs, files in os.walk(source_dir):
        for f in files:
            if f.lower().endswith('.txt'):
                file_paths.append(os.path.join(root, f))
    total_files = len(file_paths)

    print(f"Processing {total_files} .txt files with {num_workers} worker processes...")

    # Initialize counters
    cleaned_count = 0
    replaced_count = 0
    invalid_count = 0

    # Use multiprocessing Pool to process files in parallel
    with multiprocessing.Pool(num_workers) as pool:
        # Use imap_unordered for better performance and integrate with tqdm
        results = []
        for result in tqdm(pool.imap_unordered(validate_json_file, file_paths), total=total_files, desc="Validating JSON files"):
            results.append(result)

    # Process the results
    for filename, is_valid, info in results:
        if is_valid:
            if info:
                cleaned_count += 1
            replaced_count += 1
        else:
            invalid_count += 1

    print(f"\nProcessing complete:")
    print(f"Valid JSON files replaced with .json: {replaced_count}")
    print(f"Files cleaned: {cleaned_count}")
    print(f"Invalid or unreadable files remain as .txt: {invalid_count}")

    print("\nDetailed results:")
    for filename, is_valid, info in results:
        if is_valid:
            if info:
                print(f"{filename} was cleaned and replaced with a .json file.")
            else:
                print(f"{filename} is valid and replaced with a .json file.")
        else:
            print(f"{filename} is invalid or unreadable. Remains as .txt. Error: {info}")

if __name__ == "__main__":
    # Specify the source directory
    source_directory = r"G:\My Drive\2024-2025\coding\rolls_txt"

    # Calculate the number of worker processes (3/4 of available CPUs)
    num_cpus = multiprocessing.cpu_count()
    num_workers = max(1, int(num_cpus * 0.75))

    # Start the validation and replacement process
    validate_and_replace_json_files(source_directory, num_workers)


********************************************************************************

File: models.py
********************************************************************************

# No longer necessary since it is NoSQL db. 

# from app import db, ma

# class OCRText(db.Model):
#     __tablename__ = 'ocr_text'
#     id = db.Column(db.Text, primary_key=True)
#     file = db.Column(db.Text, nullable=False)
#     text = db.Column(db.Text, nullable=False)

#     summary = db.relationship('Summary', back_populates='ocr_text', uselist=False)
#     named_entities = db.relationship('NamedEntity', back_populates='ocr_text')
#     dates = db.relationship('Date', back_populates='ocr_text')
#     monetary_amounts = db.relationship('MonetaryAmount', back_populates='ocr_text')
#     relationships = db.relationship('Relationship', back_populates='ocr_text')
#     document_metadata = db.relationship('DocumentMetadata', back_populates='ocr_text', uselist=False)
#     translation = db.relationship('Translation', back_populates='ocr_text', uselist=False)
#     file_info = db.relationship('FileInfo', back_populates='ocr_text', uselist=False)

# class Summary(db.Model):
#     __tablename__ = 'summary'
#     id = db.Column(db.Text, primary_key=True)
#     file = db.Column(db.Text, db.ForeignKey('ocr_text.id'), nullable=False)
#     text = db.Column(db.Text, nullable=False)

#     ocr_text = db.relationship('OCRText', back_populates='summary')

# class NamedEntity(db.Model):
#     __tablename__ = 'named_entities'
#     id = db.Column(db.Text, primary_key=True)
#     file = db.Column(db.Text, db.ForeignKey('ocr_text.id'), nullable=False)
#     entity = db.Column(db.Text, nullable=False)
#     type = db.Column(db.Text, nullable=False)

#     ocr_text = db.relationship('OCRText', back_populates='named_entities')

# class Date(db.Model):
#     __tablename__ = 'dates'
#     id = db.Column(db.Text, primary_key=True)
#     file = db.Column(db.Text, db.ForeignKey('ocr_text.id'), nullable=False)
#     date = db.Column(db.Text, nullable=False)

#     ocr_text = db.relationship('OCRText', back_populates='dates')

# class MonetaryAmount(db.Model):
#     __tablename__ = 'monetary_amounts'
#     id = db.Column(db.Text, primary_key=True)
#     file = db.Column(db.Text, db.ForeignKey('ocr_text.id'), nullable=False)
#     amount = db.Column(db.Text, nullable=False)
#     category = db.Column(db.Text, nullable=False)

#     ocr_text = db.relationship('OCRText', back_populates='monetary_amounts')

# class Relationship(db.Model):
#     __tablename__ = 'relationships'
#     id = db.Column(db.Text, primary_key=True)
#     file = db.Column(db.Text, db.ForeignKey('ocr_text.id'), nullable=False)
#     entity1 = db.Column(db.Text, nullable=False)
#     relationship = db.Column(db.Text, nullable=False)
#     entity2 = db.Column(db.Text, nullable=False)

#     ocr_text = db.relationship('OCRText', back_populates='relationships')

# class DocumentMetadata(db.Model):
#     __tablename__ = 'metadata'
#     id = db.Column(db.Text, primary_key=True)
#     file = db.Column(db.Text, db.ForeignKey('ocr_text.id'), nullable=False)
#     document_type = db.Column(db.Text, nullable=False)
#     period = db.Column(db.Text, nullable=False)
#     context = db.Column(db.Text, nullable=False)
#     sentiment = db.Column(db.Text, nullable=False)

#     ocr_text = db.relationship('OCRText', back_populates='document_metadata')

# class Translation(db.Model):
#     __tablename__ = 'translation'
#     id = db.Column(db.Text, primary_key=True)
#     file = db.Column(db.Text, db.ForeignKey('ocr_text.id'), nullable=False)
#     french_text = db.Column(db.Text, nullable=False)
#     english_translation = db.Column(db.Text, nullable=False)

#     ocr_text = db.relationship('OCRText', back_populates='translation')

# class FileInfo(db.Model):
#     __tablename__ = 'file_info'
#     id = db.Column(db.Text, primary_key=True)
#     file = db.Column(db.Text, db.ForeignKey('ocr_text.id'), nullable=False)
#     original_filepath = db.Column(db.Text, nullable=False)

#     ocr_text = db.relationship('OCRText', back_populates='file_info')

# # Add Marshmallow schemas if needed
# class OCRTextSchema(ma.SQLAlchemyAutoSchema):
#     class Meta:
#         model = OCRText


********************************************************************************

File: static\script.js
********************************************************************************

// File: static/script.js

document.addEventListener('DOMContentLoaded', function() {
    // ===============================
    // Initialization
    // ===============================
    const searchForm = document.getElementById('searchForm');
    const resultsDiv = document.getElementById('results');
    const loadingIndicator = document.getElementById('loadingIndicator');
    const cancelButton = document.getElementById('cancelSearch');
    const totalResultsDiv = document.getElementById('totalResults');
    const exportSelectedCsvButton = document.getElementById('exportSelectedCsv');

    // Add console warnings for missing elements
    if (!searchForm) console.warn('Search form not found');
    if (!resultsDiv) console.warn('Results div not found');
    if (!loadingIndicator) console.warn('Loading indicator not found');
    if (!cancelButton) console.warn('Cancel button not found');
    if (!totalResultsDiv) console.warn('Total results div not found');
    if (!exportSelectedCsvButton) console.warn('Export Selected CSV button not found');

    // Pagination and Search Variables
    let controller;
    let page = 1;
    let totalPages = 1;
    const perPage = 50;  // Fixed number of results per request
    let totalResults = 0;
    let isLoading = false;
    let hasMore = true;
    let currentQuery = {};
    let prefetchedData = null;

    // Selection Management
    let selectedDocuments = new Set();

    // ===============================
    // Utility Functions
    // ===============================

    /**
     * Debounce function to limit the rate at which a function can fire.
     * @param {Function} func - The function to debounce.
     * @param {number} delay - The delay in milliseconds.
     * @returns {Function} - The debounced function.
     */
    function debounce(func, delay) {
        let timeoutId;
        return function(...args) {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => func.apply(this, args), delay);
        };
    }

    /**
     * Toggles the selection of a document.
     * @param {string} docId - The ID of the document.
     * @param {boolean} isSelected - Whether the document is selected.
     */
    function toggleDocumentSelection(docId, isSelected) {
        if (isSelected) {
            selectedDocuments.add(docId);
        } else {
            selectedDocuments.delete(docId);
        }
        updateExportButtonVisibility();
        saveSelectedDocuments();
    }

    /**
     * Updates the visibility of the Export Selected button based on selections.
     */
    function updateExportButtonVisibility() {
        if (!exportSelectedCsvButton) return;
        if (selectedDocuments.size > 0) {
            exportSelectedCsvButton.style.display = 'inline-block';
        } else {
            exportSelectedCsvButton.style.display = 'none';
        }
    }

    /**
     * Saves the selected documents to localStorage.
     */
    function saveSelectedDocuments() {
        localStorage.setItem('selectedDocuments', JSON.stringify(Array.from(selectedDocuments)));
    }

    /**
     * Loads the selected documents from localStorage.
     */
    function loadSelectedDocuments() {
        const savedSelectedDocuments = JSON.parse(localStorage.getItem('selectedDocuments') || '[]');
        savedSelectedDocuments.forEach(id => selectedDocuments.add(id));
        updateExportButtonVisibility();
    }

    /**
     * Shows the loading indicator.
     */
    function showLoadingIndicator() {
        if (loadingIndicator && loadingIndicator.style) {
            loadingIndicator.style.display = 'block';
        }
    }

    /**
     * Hides the loading indicator.
     */
    function hideLoadingIndicator() {
        if (loadingIndicator && loadingIndicator.style) {
            loadingIndicator.style.display = 'none';
        }
    }

    /**
     * Resets the search parameters and UI elements.
     */
    function resetSearch() {
        page = 1;
        hasMore = true;
        if (resultsDiv) resultsDiv.innerHTML = '';
        if (totalResultsDiv) totalResultsDiv.textContent = '';
    }

    /**
     * Gathers search parameters from the form.
     */
    function gatherSearchParameters() {
        const formData = new FormData(searchForm);
        currentQuery = {};
        for (let i = 1; i <= 3; i++) {
            currentQuery[`field${i}`] = formData.get(`field${i}`);
            currentQuery[`operator${i}`] = formData.get(`operator${i}`);
            currentQuery[`searchTerm${i}`] = formData.get(`searchTerm${i}`);
        }
    }

    /**
     * Validates the search parameters.
     * @returns {boolean} True if valid, else false.
     */
    function validateSearchParameters() {
        if (!currentQuery['field1'] || !currentQuery['searchTerm1']) {
            console.error('Please enter a valid search term in the first field.');
            alert('Please enter a valid search term in the first field.');
            return false;
        }
        return true;
    }

    /**
     * Handles the scroll event for infinite scrolling.
     */
    function handleScroll() {
        const scrollPosition = window.innerHeight + window.scrollY;
        const threshold = document.body.offsetHeight - 100;

        if (scrollPosition >= threshold) {
            if (prefetchedData) {
                // Use prefetched data
                appendResults(prefetchedData.documents);
                page += 1;
                totalPages = prefetchedData.total_pages;
                totalResults = prefetchedData.total_count;
                updateTotalResults();

                // Clear prefetched data and prefetch the next page
                prefetchedData = null;
                if (page <= totalPages) {
                    prefetchNextPage();
                } else {
                    hasMore = false;
                }
            } else {
                performSearch();
            }
        } else if (prefetchedData === null && (scrollPosition >= threshold / 2)) {
            // Start prefetching when user scrolls halfway
            prefetchNextPage();
        }
    }

    // ===============================
    // Event Listeners
    // ===============================

    // Handle form submission for search
    if (searchForm) {
        searchForm.addEventListener('submit', function(e) {
            e.preventDefault();
            resetSearch();
            gatherSearchParameters();
            if (validateSearchParameters()) {
                performSearch(true);
            }
        });
    }

    // Handle checkbox changes using event delegation
    if (resultsDiv) {
        resultsDiv.addEventListener('change', function(e) {
            if (e.target && e.target.matches('.select-document')) {
                const docId = e.target.getAttribute('data-doc-id');
                toggleDocumentSelection(docId, e.target.checked);
            }
        });
    }

    // Handle "Select All" functionality
    if (resultsDiv) {
        resultsDiv.addEventListener('change', function(e) {
            if (e.target && e.target.matches('#selectAll')) {
                const checkboxes = resultsDiv.querySelectorAll('.select-document');
                const isChecked = e.target.checked;
                checkboxes.forEach(cb => {
                    cb.checked = isChecked;
                    const docId = cb.getAttribute('data-doc-id');
                    if (isChecked) {
                        selectedDocuments.add(docId);
                    } else {
                        selectedDocuments.delete(docId);
                    }
                });
                updateExportButtonVisibility();
                saveSelectedDocuments();
            }
        });
    }

    // Handle Export Selected to CSV Button Click
    if (exportSelectedCsvButton) {
        exportSelectedCsvButton.addEventListener('click', function() {
            exportSelectedDocuments();
        });
    }

    // Handle Cancel Search Button Click
    if (cancelButton) {
        cancelButton.addEventListener('click', function() {
            cancelSearch();
        });
    }

    // Handle Infinite Scroll with Debounce
    window.addEventListener('scroll', debounce(handleScroll, 200));

    // ===============================
    // Search Functionality
    // ===============================

    /**
     * Performs the search by sending a POST request to the server.
     * @param {boolean} isNewSearch - Indicates if it's a new search.
     */
    function performSearch(isNewSearch = false) {
        if (isLoading || !hasMore) return;
        isLoading = true;

        if (isNewSearch) {
            prefetchedData = null;
        }

        showLoadingIndicator();
        if (cancelButton) cancelButton.style.display = 'inline-block';

        // Add page and perPage to currentQuery
        currentQuery.page = page;
        currentQuery.per_page = perPage;

        controller = new AbortController();
        const signal = controller.signal;

        fetch('/search', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(currentQuery),
            signal: signal
        })
        .then(response => response.json())
        .then(data => {
            hideLoadingIndicator();
            if (cancelButton) cancelButton.style.display = 'none';
            if (data.documents && data.documents.length > 0) {
                appendResults(data.documents);
                totalPages = data.total_pages;
                totalResults = data.total_count;

                // Prefetch the next page if there are more pages
                if (page < totalPages) {
                    page += 1;
                    prefetchNextPage();
                } else {
                    hasMore = false;
                }
            } else {
                hasMore = false;
                if (isNewSearch && resultsDiv && resultsDiv.innerHTML === '') {
                    resultsDiv.innerHTML = '<p>No results found.</p>';
                }
            }
            updateTotalResults();
            isLoading = false;
        })
        .catch(error => {
            hideLoadingIndicator();
            if (cancelButton) cancelButton.style.display = 'none';
            isLoading = false;
            if (error.name === 'AbortError') {
                console.log('Search was cancelled');
            } else {
                console.error('Error:', error);
                alert('An error occurred during the search. Please try again.');
            }
        });
    }

    /**
     * Appends search results to the resultsDiv.
     * @param {Array} documents - List of document objects.
     */
    function appendResults(documents) {
        if (!resultsDiv) return;

        let table = document.getElementById('resultsTable');
        let tbody;

        // If the table doesn't exist yet, create it
        if (!table) {
            table = document.createElement('table');
            table.id = 'resultsTable';

            // Create table headers with a Select All checkbox
            const thead = document.createElement('thead');
            thead.innerHTML = `
                <tr>
                    <th><input type="checkbox" id="selectAll" /></th>
                    <th>File</th>
                    <th>Summary</th>
                </tr>
            `;
            table.appendChild(thead);

            // Create table body
            tbody = document.createElement('tbody');
            table.appendChild(tbody);

            // Append the table to the results div
            resultsDiv.appendChild(table);
        } else {
            // If the table exists, get its tbody
            tbody = table.querySelector('tbody');
        }

        // Append new rows to the table body
        documents.forEach(doc => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td><input type="checkbox" class="select-document" data-doc-id="${doc._id}" /></td>
                <td><a href="/document/${doc._id}">${doc.filename || 'No file name'}</a></td>
                <td>${doc.summary || 'No summary available.'}</td>
            `;
            // If the document is already selected, check the box
            if (selectedDocuments.has(doc._id)) {
                row.querySelector('.select-document').checked = true;
            }
            tbody.appendChild(row);
        });
    }

    /**
     * Updates the total results display.
     */
    function updateTotalResults() {
        if (totalResultsDiv) {
            totalResultsDiv.textContent = `Total results: ${totalResults}`;
        }
    }

    /**
     * Prefetches the next page of results.
     */
    function prefetchNextPage() {
        if (prefetchedData || !hasMore) return;

        const prefetchQuery = { ...currentQuery, page: page };

        fetch('/search', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(prefetchQuery),
        })
        .then(response => response.json())
        .then(data => {
            if (data.documents && data.documents.length > 0) {
                prefetchedData = data;
            } else {
                hasMore = false;
            }
        })
        .catch(error => {
            console.error('Error during prefetching:', error);
        });
    }

    // ===============================
    // Selection Management
    // ===============================

    /**
     * Exports the selected documents to CSV.
     */
    function exportSelectedDocuments() {
        if (selectedDocuments.size === 0) {
            alert('No documents selected.');
            return;
        }

        // Prepare the list of selected document IDs
        const selectedIds = Array.from(selectedDocuments);

        // Show a loading modal or notification
        showExportModal('Exporting selected documents...');

        // Send the list to the server via POST
        fetch('/export_selected_csv', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ document_ids: selectedIds }),
        })
        .then(response => {
            if (response.ok) {
                return response.blob();
            } else {
                return response.json().then(err => { throw err; });
            }
        })
        .then(blob => {
            // Create a link to download the blob
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'selected_documents.csv';
            document.body.appendChild(a);
            a.click();
            a.remove();
            window.URL.revokeObjectURL(url);

            // Hide the export modal and show success message
            hideExportModal();
            showExportModal('Export successful!', 'success');

            // Reset the export button
            exportSelectedCsvButton.disabled = false;
            exportSelectedCsvButton.textContent = 'Export Selected to CSV';

            // Optionally, clear the selectedDocuments set
            selectedDocuments.clear();
            updateExportButtonVisibility();

            // Uncheck all checkboxes
            const checkboxes = resultsDiv.querySelectorAll('.select-document');
            checkboxes.forEach(cb => cb.checked = false);

            // Uncheck "Select All" checkbox
            const selectAllCheckbox = document.getElementById('selectAll');
            if (selectAllCheckbox) {
                selectAllCheckbox.checked = false;
            }

            // Remove success message after a short delay
            setTimeout(() => {
                hideExportModal();
            }, 3000);
        })
        .catch(error => {
            console.error('Error exporting selected documents:', error);
            hideExportModal();
            alert('Error exporting selected documents.');

            // Reset the export button
            exportSelectedCsvButton.disabled = false;
            exportSelectedCsvButton.textContent = 'Export Selected to CSV';
        });
    }

    /**
     * Cancels the ongoing search.
     */
    function cancelSearch() {
        if (controller) {
            controller.abort();
            hideLoadingIndicator();
            isLoading = false;
            hasMore = false;
            if (cancelButton) cancelButton.style.display = 'none';
        }
    }

    // ===============================
    // Export Feedback Mechanism
    // ===============================

    /**
     * Creates and displays an export modal for feedback.
     * @param {string} message - The message to display.
     * @param {string} type - The type of message ('info', 'success', 'error').
     */
    function showExportModal(message, type = 'info') {
        // Check if modal already exists
        let modal = document.getElementById('exportModal');
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'exportModal';
            modal.innerHTML = `
                <div class="modal-content">
                    <span class="close-button">&times;</span>
                    <p id="exportMessage">${message}</p>
                </div>
            `;
            document.body.appendChild(modal);

            // Style the modal
            const style = document.createElement('style');
            style.textContent = `
                #exportModal {
                    display: block; 
                    position: fixed; 
                    z-index: 1000; 
                    left: 0;
                    top: 0;
                    width: 100%; 
                    height: 100%; 
                    overflow: auto; 
                    background-color: rgba(0,0,0,0.4); 
                }
                .modal-content {
                    background-color: #fefefe;
                    margin: 15% auto; 
                    padding: 20px;
                    border: 1px solid #888;
                    width: 300px; 
                    text-align: center;
                    border-radius: 5px;
                }
                .close-button {
                    color: #aaa;
                    float: right;
                    font-size: 28px;
                    font-weight: bold;
                    cursor: pointer;
                }
                .close-button:hover,
                .close-button:focus {
                    color: black;
                    text-decoration: none;
                }
                .modal-content.success {
                    border-color: #28a745;
                }
                .modal-content.error {
                    border-color: #dc3545;
                }
            `;
            document.head.appendChild(style);

            // Handle close button click
            modal.querySelector('.close-button').addEventListener('click', hideExportModal);
        }

        // Update the message and style based on type
        const exportMessage = modal.querySelector('#exportMessage');
        exportMessage.textContent = message;
        modal.querySelector('.modal-content').className = 'modal-content'; // Reset classes

        if (type === 'success') {
            modal.querySelector('.modal-content').classList.add('success');
        } else if (type === 'error') {
            modal.querySelector('.modal-content').classList.add('error');
        }

        // Display the modal
        modal.style.display = 'block';
    }

    /**
     * Hides the export modal.
     */
    function hideExportModal() {
        const modal = document.getElementById('exportModal');
        if (modal) {
            modal.style.display = 'none';
        }
    }

    // ===============================
    // Initial Load
    // ===============================

    // Load selected documents from localStorage
    loadSelectedDocuments();
});


********************************************************************************

File: static\style.css
********************************************************************************

/* static/style.css */

body {
    font-family: 'Open Sans', sans-serif;
    font-size: 16px;
    line-height: 1.6;
    background-color: #ffffff;
    color: #333;
    margin: 0;
    padding: 0;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

h1, h2, h3 {
    font-family: 'Montserrat', sans-serif;
    color: #333;
    margin-bottom: 20px;
}

/* Navigation */
nav ul {
    list-style-type: none;
    padding: 0;
    margin-bottom: 20px;
}

nav ul li {
    display: inline;
    margin-right: 10px;
}

nav ul li a {
    text-decoration: none;
    color: #007bff;
}

nav ul li a:hover {
    text-decoration: underline;
}

/* Search Form */
.search-field {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    align-items: center;
}

input[type="text"], select {
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 16px;
}

button {
    padding: 10px 20px;
    background-color: #007bff;
    color: #fff;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s ease;
    font-size: 16px;
}

button:hover {
    background-color: #0056b3;
}

/* Results Table */
#results table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
}

#results th, #results td {
    padding: 12px;
    text-align: left;
    border-bottom: 1px solid #ddd;
}

#results th {
    background-color: #f0f0f0;
    font-weight: bold;
}

#results tbody tr:nth-child(odd) {
    background-color: #f9f9f9;
}

#results tbody tr:nth-child(even) {
    background-color: #ffffff;
}

#results tbody tr:hover {
    background-color: #eaeaea;
}

#results a {
    color: #007bff;
    text-decoration: none;
}

#results a:hover {
    text-decoration: underline;
}

/* Loading Indicator */
#loadingIndicator {
    text-align: center;
    margin-top: 20px;
}

.spinner {
    border: 4px solid #f3f3f3;
    border-top: 4px solid #3498db;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    animation: spin 1s linear infinite;
    margin: 0 auto;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Additional Styles */
.mt-4 {
    margin-top: 1rem;
}

.ml-auto {
    margin-left: auto;
}

/* Error Messages */
.error {
    color: #dc3545;
    font-weight: bold;
}

/* Document Detail Styles */
.document-detail .detail-container {
    display: flex;
    gap: 20px;
}

.document-detail .info-panel {
    flex: 1;
}

.document-detail .image-panel {
    flex: 1;
    position: relative;
}

#imageContainer {
    overflow: auto;
    max-width: 100%;
    max-height: 600px;
}

#documentImage {
    max-width: 100%;
    max-height: 100%;
    transform-origin: top left;
}

.zoom-controls {
    margin-top: 10px;
}

.zoom-controls button {
    margin-right: 5px;
}



/* Loading Indicator */
#loadingIndicator {
    text-align: center;
    margin-top: 20px;
}

.spinner {
    border: 4px solid #f3f3f3;
    border-top: 4px solid #3498db;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    animation: spin 1s linear infinite;
    margin: 0 auto;
}

.info-section {
    margin-bottom: 20px;
    border: 1px solid #e0e0e0;
    border-radius: 5px;
    padding: 15px;
}

.info-table, .nested-table {
    width: 100%;
    border-collapse: collapse;
}

.info-table th, .info-table td,
.nested-table th, .nested-table td {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: left;
}

.info-table th, .nested-table th {
    background-color: #f2f2f2;
}

.nested-list, .info-list {
    list-style-type: none;
    padding-left: 0;
}

.nested-list li, .info-list li {
    margin-bottom: 10px;
}


/* File: static/style.css */

body {
    font-family: Arial, sans-serif;
    background-color: #f9f9f9;
    color: #333;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

nav ul {
    list-style-type: none;
    padding: 0;
    display: flex;
    gap: 15px;
}

nav ul li {
    display: inline;
}

nav ul li a {
    text-decoration: none;
    color: #3498db;
    font-weight: bold;
}

nav ul li a:hover {
    text-decoration: underline;
}

.flashes {
    list-style-type: none;
    padding: 0;
    color: red;
}

form div {
    margin-bottom: 15px;
}

button {
    padding: 10px 20px;
    background-color: #3498db;
    color: white;
    border: none;
    cursor: pointer;
}

button:hover {
    background-color: #2980b9;
}



********************************************************************************

File: templates\document-detail.html
********************************************************************************

{% extends "base.html" %}

{% macro render_json(key, value) %}
  <div class="info-section">
    <h2>{{ key|title }}</h2>
    {{ render_value(value) }}
  </div>
{% endmacro %}

{% macro render_value(value) %}
  {% if value is mapping %}
    <table class="info-table">
      {% for subkey, subvalue in value.items() %}
        <tr>
          <th>{{ subkey|title }}</th>
          <td>
            {{ render_value(subvalue) }}
          </td>
        </tr>
      {% endfor %}
    </table>
  {% elif value is iterable and value is not string %}
    <ul class="info-list">
      {% for item in value %}
        <li>
          {% if item is mapping %}
            <div class="nested-mapping">
              {% for itemkey, itemvalue in item.items() %}
                <strong>{{ itemkey|title }}:</strong> {{ render_value(itemvalue) }}<br>
              {% endfor %}
            </div>
          {% else %}
            {{ item }}
          {% endif %}
        </li>
      {% endfor %}
    </ul>
  {% else %}
    {{ value if value is not none else 'N/A' }}
  {% endif %}
{% endmacro %}

{% block content %}
<div class="document-detail">
  <div class="detail-container">
    <div class="info-panel">
      <div class="navigation">
        <a href="{{ url_for('index') }}?return_to_search=true" class="nav-button" title="Return to Search Results">
          <i class="fas fa-search"></i>
        </a>
        <a href="{{ prev_id and url_for('document_detail', doc_id=prev_id) or '#' }}" class="nav-button {{ 'disabled' if not prev_id else '' }}" title="Previous Result">
          <i class="fas fa-chevron-left"></i>
        </a>
        <a href="{{ url_for('index') }}" class="nav-button" title="Home">
          <i class="fas fa-home"></i>
        </a>
        <a href="{{ next_id and url_for('document_detail', doc_id=next_id) or '#' }}" class="nav-button {{ 'disabled' if not next_id else '' }}" title="Next Result">
          <i class="fas fa-chevron-right"></i>
        </a>
      </div>
  
      <h1>{{ document.get('filename', 'Untitled Document') }}</h1>

      <div class="info-container">
        {% for key, value in document.items() %}
          {% if key != '_id' and key != 'filename' %}
            {{ render_json(key, value) }}
          {% endif %}
        {% endfor %}
      </div>
    </div>

    <div class="image-panel">
      {% if document.get('file_info', {}).get('original_filepath') %}
        <div id="imageContainer">
          <img id="documentImage" src="{{ url_for('serve_image', filename=document['file_info']['original_filepath']) }}" alt="Document Image">
        </div>
        <div class="zoom-controls">
          <button id="zoomIn">Zoom In</button>
          <button id="zoomOut">Zoom Out</button>
          <button id="resetZoom">Reset</button>
        </div>
      {% else %}
        <div class="placeholder-image">
          [Placeholder for Document Image]
        </div>
      {% endif %}
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
  let scale = 1;
  const ZOOM_STEP = 0.1;
  const MAX_SCALE = 3;
  const MIN_SCALE = 0.5;

  const imageContainer = document.getElementById('imageContainer');
  const documentImage = document.getElementById('documentImage');
  const zoomInBtn = document.getElementById('zoomIn');
  const zoomOutBtn = document.getElementById('zoomOut');
  const resetZoomBtn = document.getElementById('resetZoom');

  function setImageTransform() {
    documentImage.style.transform = `scale(${scale})`;
  }

  function zoomIn() {
    if (scale < MAX_SCALE) {
      scale += ZOOM_STEP;
      setImageTransform();
    }
  }

  function zoomOut() {
    if (scale > MIN_SCALE) {
      scale -= ZOOM_STEP;
      setImageTransform();
    }
  }

  function resetZoom() {
    scale = 1;
    setImageTransform();
  }

  zoomInBtn.addEventListener('click', zoomIn);
  zoomOutBtn.addEventListener('click', zoomOut);
  resetZoomBtn.addEventListener('click', resetZoom);

  let isDragging = false;
  let startX, startY, scrollLeft, scrollTop;

  imageContainer.addEventListener('mousedown', (e) => {
    isDragging = true;
    startX = e.pageX - imageContainer.offsetLeft;
    startY = e.pageY - imageContainer.offsetTop;
    scrollLeft = imageContainer.scrollLeft;
    scrollTop = imageContainer.scrollTop;
  });

  imageContainer.addEventListener('mouseleave', () => {
    isDragging = false;
  });

  imageContainer.addEventListener('mouseup', () => {
    isDragging = false;
  });

  imageContainer.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    e.preventDefault();
    const x = e.pageX - imageContainer.offsetLeft;
    const y = e.pageY - imageContainer.offsetTop;
    const walkX = (x - startX) * 2;
    const walkY = (y - startY) * 2;
    imageContainer.scrollLeft = scrollLeft - walkX;
    imageContainer.scrollTop = scrollTop - walkY;
  });
</script>
{% endblock %}


********************************************************************************

File: templates\document-list.html
********************************************************************************

<!-- templates/document-list.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document List</title>
</head>
<body>
    <h1>Document List</h1>

    <ul id="documentList">
    {% for document in documents %}
        <li>
            <a href="{{ url_for('document_detail', doc_id=document['_id']) }}" target="_blank" rel="noopener noreferrer" class="document-link">{{ document.get('filename', 'Untitled Document') }}</a>
        </li>
    {% endfor %}
    </ul>
</body>
</html>


********************************************************************************

File: templates\error.html
********************************************************************************

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Error</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <h1>Error</h1>
    <p>{{ message }}</p>
    <a href="{{ url_for('index') }}">Return to Home</a>
</body>
</html>


********************************************************************************

File: templates\index.html
********************************************************************************

<!-- File: templates/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Historical Document Reader</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Open+Sans&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div class="container">
        <h1 class="mt-4">Historical Document Reader</h1>
        <nav>
            <ul>
                <li><a href="{{ url_for('index') }}">Home</a></li>
                <li><a href="{{ url_for('search_terms') }}">Search Terms</a></li>
                <li><a href="{{ url_for('database_info') }}">Database Info</a></li>
                <li><a href="{{ url_for('settings') }}">Settings</a></li>
                {% if 'logged_in' in session %}
                    <li><a href="{{ url_for('logout') }}">Logout</a></li>
                {% else %}
                    <li><a href="{{ url_for('login') }}">Login</a></li>
                {% endif %}
            </ul>
        </nav>

        <form id="searchForm">
            <div id="searchFields">
                {% for i in range(1, num_search_fields + 1) %}
                <div class="search-field">
                    <label for="field{{ i }}">Field:</label>
                    <select name="field{{ i }}" id="field{{ i }}">
                        <option value="" disabled selected>Select a field</option>
                        {% for field in field_structure|dictsort %}
                            <option value="{{ field[0] }}">{{ field[0] }}</option>
                        {% endfor %}
                    </select>
                    <label for="operator{{ i }}">Operator:</label>
                    <select name="operator{{ i }}" id="operator{{ i }}">
                        <option value="AND">AND</option>
                        <option value="OR">OR</option>
                        <option value="NOT">NOT</option>
                    </select>
                    <label for="searchTerm{{ i }}">Search Term:</label>
                    <input type="text" name="searchTerm{{ i }}" id="searchTerm{{ i }}" placeholder="Enter search term">
                </div>
                {% endfor %}
            </div>
            <button type="submit" id="searchButton">Search</button>
        </form>

        <!-- Loading Indicator -->
        <div id="loadingIndicator" style="display: none;">
            <div class="spinner"></div>
            <p>Loading... Please wait.</p>
        </div>

        <!-- Cancel Search Button -->
        <button id="cancelSearch" style="display: none;">Cancel Search</button>

        <!-- Total Results Display -->
        <div id="totalResults" class="mt-4"></div>

        <!-- Results Container -->
        <div id="results" class="mt-4">
            <!-- The table will be dynamically inserted here -->
        </div>

        <!-- Export Selected to CSV Button -->
        <button id="exportSelectedCsv" style="display: none; margin-top: 10px;">Export Selected to CSV</button>
    </div>

    <!-- Include jQuery -->
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <!-- Include your custom script -->
    <script src="{{ url_for('static', filename='script.js') }}"></script>
</body>
</html>


********************************************************************************

File: templates\search-terms.html
********************************************************************************

<!-- File: templates/search-terms.html -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Search Terms</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <!-- Include DataTables CSS -->
    <link rel="stylesheet" href="https://cdn.datatables.net/1.10.21/css/jquery.dataTables.css">
    <style>
        #loadingIndicator {
            display: none;
            text-align: center;
            margin-top: 20px;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        nav ul {
            list-style-type: none;
            padding: 0;
            display: flex;
            gap: 15px;
        }
        nav ul li {
            display: inline;
        }
        nav ul li a {
            text-decoration: none;
            color: #3498db;
            font-weight: bold;
        }
        nav ul li a:hover {
            text-decoration: underline;
        }
        .section {
            margin-top: 30px;
        }
        #noDataMessage {
            display: none;
            color: red;
            margin-top: 20px;
            font-weight: bold;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Search Terms</h1>
        <nav>
            <ul>
                <li><a href="{{ url_for('index') }}">Home</a></li>
                <li><a href="{{ url_for('search_terms') }}">Search Terms</a></li>
                <li><a href="{{ url_for('database_info') }}">Database Info</a></li>
                <li><a href="{{ url_for('settings') }}">Settings</a></li>
            </ul>
        </nav>
        <div style="margin-top: 20px;">
            <label for="fieldSelect">Select Field:</label>
            <select id="fieldSelect">
                <option value="" disabled selected>Select a field</option>
                {% for field in field_structure|dictsort %}
                    {% if field[0] not in unique_fields %}
                        <option value="{{ field[0] }}">{{ field[0] }}</option>
                    {% endif %}
                {% endfor %}
            </select>
        </div>
        <div id="tableInfo" style="margin-top: 10px;">
            <p>Number of unique words: <span id="uniqueWords">0</span></p>
            <p>Number of unique phrases: <span id="uniquePhrases">0</span></p>
            <p>Total number of records: <span id="totalRecords">0</span></p>
        </div>
        <div id="loadingIndicator">
            <div class="spinner"></div>
            <p>Loading data...</p>
        </div>
        <!-- No Data Message -->
        <div id="noDataMessage"></div>
        <div class="section">
            <h2>Words</h2>
            <table id="wordsTable" class="display" style="width:100%; margin-top: 10px;">
                <thead>
                    <tr>
                        <th>Word</th>
                        <th>Count</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Initially empty; populated via AJAX -->
                </tbody>
            </table>
        </div>
        <div class="section">
            <h2>Phrases</h2>
            <table id="phrasesTable" class="display" style="width:100%; margin-top: 10px;">
                <thead>
                    <tr>
                        <th>Phrase</th>
                        <th>Count</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Initially empty; populated via AJAX -->
                </tbody>
            </table>
        </div>
    </div>
    <!-- Include jQuery and DataTables JS -->
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://cdn.datatables.net/1.10.21/js/jquery.dataTables.js"></script>
    <script>
        $(document).ready(function() {
            var wordsTable = $('#wordsTable').DataTable({
                "pageLength": 25,
                "order": [[ 0, "asc" ]],
                "columns": [
                    { "data": "word" },
                    { "data": "count" }
                ]
            });

            var phrasesTable = $('#phrasesTable').DataTable({
                "pageLength": 25,
                "order": [[ 0, "asc" ]],
                "columns": [
                    { "data": "phrase" },
                    { "data": "count" }
                ]
            });

            function updateTableInfo(data) {
                $('#uniqueWords').text(data.unique_words);
                $('#uniquePhrases').text(data.unique_phrases);
                $('#totalRecords').text(data.total_records);
            }

            $('#fieldSelect').on('change', function() {
                var selectedField = $(this).val();
                if (!selectedField) {
                    wordsTable.clear().draw();
                    phrasesTable.clear().draw();
                    updateTableInfo({ unique_words: 0, unique_phrases: 0, total_records: 0 });
                    $('#noDataMessage').hide();
                    return;
                }

                $('#loadingIndicator').show();
                $('#noDataMessage').hide();
                $('#wordsTableContainer').show();
                $('#phrasesTableContainer').show();

                $.ajax({
                    url: '/search-terms',
                    data: { field: selectedField },
                    success: function(data) {
                        // Check if both words and phrases are empty
                        if (data.words.length === 0 && data.phrases.length === 0) {
                            // Hide the tables
                            $('.section').hide();
                            // Show the no data message
                            $('#noDataMessage').text(data.message || 'No data available for this field.').show();
                        } else {
                            // Show the tables in case they were hidden
                            $('.section').show();
                            // Hide the no data message
                            $('#noDataMessage').hide();

                            // Populate words table
                            wordsTable.clear();
                            data.words.forEach(function(word) {
                                wordsTable.row.add({ word: word.word, count: word.count });
                            });
                            wordsTable.draw();

                            // Populate phrases table
                            phrasesTable.clear();
                            data.phrases.forEach(function(phrase) {
                                phrasesTable.row.add({ phrase: phrase.phrase, count: phrase.count });
                            });
                            phrasesTable.draw();
                        }

                        // Update table info
                        updateTableInfo(data);
                        $('#loadingIndicator').hide();
                    },
                    error: function() {
                        alert('Error fetching data. Please try again.');
                        $('#loadingIndicator').hide();
                    }
                });
            });
        });
    </script>
</body>
</html>


********************************************************************************

File: templates\database-info.html
********************************************************************************

<!-- templates/database-info.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Database Information</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div class="container">
        <h1>Database Information</h1>
        <nav>
            <ul>
                <li><a href="{{ url_for('index') }}">Home</a></li>
                <li><a href="{{ url_for('search_terms') }}">Search Terms</a></li>
                <li><a href="{{ url_for('database_info') }}">Database Info</a></li>
                <li><a href="{{ url_for('settings') }}">Settings</a></li>
            </ul>
        </nav>
        <table>
            <thead>
                <tr>
                    <th>Field Name</th>
                    <th>Number of Records</th>
                </tr>
            </thead>
            <tbody>
                {% for field in collection_info %}
                <tr>
                    <td>{{ field.name }}</td>
                    <td>{{ field.count }}</td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
</body>
</html>


********************************************************************************

File: templates\settings.html
********************************************************************************

<!-- File: templates/settings.html -->

{% extends "base.html" %}

{% block content %}
<div class="container">
    <h1>Settings</h1>
    <form method="POST">
        <h2>Fonts</h2>
        <label for="fonts_main">Main Font:</label>
        <input type="text" id="fonts_main" name="fonts[main]" value="{{ config['fonts']['main'] }}"><br>
        <label for="fonts_headers">Headers Font:</label>
        <input type="text" id="fonts_headers" name="fonts[headers]" value="{{ config['fonts']['headers'] }}"><br>

        <h2>Sizes</h2>
        <label for="sizes_base">Base Size:</label>
        <input type="text" id="sizes_base" name="sizes[base]" value="{{ config['sizes']['base'] }}"><br>
        <label for="sizes_h1">H1 Size:</label>
        <input type="text" id="sizes_h1" name="sizes[h1]" value="{{ config['sizes']['h1'] }}"><br>
        <label for="sizes_h2">H2 Size:</label>
        <input type="text" id="sizes_h2" name="sizes[h2]" value="{{ config['sizes']['h2'] }}"><br>
        <label for="sizes_h3">H3 Size:</label>
        <input type="text" id="sizes_h3" name="sizes[h3]" value="{{ config['sizes']['h3'] }}"><br>

        <h2>Colors</h2>
        <label for="colors_primary">Primary Color:</label>
        <input type="color" id="colors_primary" name="colors[primary]" value="{{ config['colors']['primary'] }}"><br>
        <label for="colors_secondary">Secondary Color:</label>
        <input type="color" id="colors_secondary" name="colors[secondary]" value="{{ config['colors']['secondary'] }}"><br>
        <label for="colors_background">Background Color:</label>
        <input type="color" id="colors_background" name="colors[background]" value="{{ config['colors']['background'] }}"><br>
        <label for="colors_text">Text Color:</label>
        <input type="color" id="colors_text" name="colors[text]" value="{{ config['colors']['text'] }}"><br>

        <h2>Spacing</h2>
        <label for="spacing_small">Small Spacing:</label>
        <input type="text" id="spacing_small" name="spacing[small]" value="{{ config['spacing']['small'] }}"><br>
        <label for="spacing_medium">Medium Spacing:</label>
        <input type="text" id="spacing_medium" name="spacing[medium]" value="{{ config['spacing']['medium'] }}"><br>
        <label for="spacing_large">Large Spacing:</label>
        <input type="text" id="spacing_large" name="spacing[large]" value="{{ config['spacing']['large'] }}"><br>

        <button type="submit">Save Settings</button>
    </form>
</div>
<script>
    // Convert nested objects to JSON strings before form submission
    document.querySelector('form').addEventListener('submit', function(e) {
        ['fonts', 'sizes', 'colors', 'spacing'].forEach(function(key) {
            var inputs = document.querySelectorAll(`[name^="${key}\\["]`);
            var obj = {};
            inputs.forEach(function(input) {
                var prop = input.name.match(/\[(.*?)\]/)[1];
                obj[prop] = input.value;
            });
            var hiddenInput = document.createElement('input');
            hiddenInput.type = 'hidden';
            hiddenInput.name = key;
            hiddenInput.value = JSON.stringify(obj);
            this.appendChild(hiddenInput);
        }, this);
    });
</script>
{% endblock %}


********************************************************************************

File: templates\base.html
********************************************************************************

<!-- templates/base.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{% block title %}Historical Document Reader{% endblock %}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <!-- Add this in the <head> section of base.html -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-yHnj4MvlYYKxE/6q9ZsH5mJ5RkJyKpjtXHYQVdG1Vl6HjnAsfsj0G9aJv1bQZoKEtZnSmhMWj58ZwFZJe61D1A==" crossorigin="anonymous" referrerpolicy="no-referrer" />

</head>
<body>
    <nav>
        <ul>
            <li><a href="{{ url_for('index') }}">Home</a></li>
            {% if session.get('logged_in') %}
                <li><a href="{{ url_for('logout') }}">Logout</a></li>
            {% else %}
                <li><a href="{{ url_for('login') }}">Login</a></li>
            {% endif %}
            <li><a href="{{ url_for('search_terms') }}">Search Terms</a></li>
            <li><a href="{{ url_for('database_info') }}">Database Info</a></li>
            <li><a href="{{ url_for('settings') }}">Settings</a></li>
        </ul>
    </nav>
    
    {% with messages = get_flashed_messages() %}
        {% if messages %}
            <ul class="flashes">
                {% for message in messages %}
                    <li>{{ message }}</li>
                {% endfor %}
            </ul>
        {% endif %}
    {% endwith %}
    
    {% block content %}{% endblock %}
</body>
</html>


********************************************************************************

File: templates\login.html
********************************************************************************

<!-- File: templates/login.html -->
<!-- Created: 2024-08-12 11:00 -->

{% extends "base.html" %}

{% block content %}
    <h1>Login</h1>
    
    {% with messages = get_flashed_messages() %}
        {% if messages %}
            <ul class="flashes">
                {% for message in messages %}
                    <li>{{ message }}</li>
                {% endfor %}
            </ul>
        {% endif %}
    {% endwith %}
    
    <form method="post">
        <label for="password">Password:</label>
        <input type="password" id="password" name="password" required>
        <br><br>
        
        <label for="captcha">CAPTCHA: What is {{ captcha_num1 }} + {{ captcha_num2 }}?</label>
        <input type="number" id="captcha" name="captcha" required>
        <input type="hidden" name="captcha_answer" value="{{ captcha_answer }}">
        <br><br>
        
        <input type="submit" value="Login">
    </form>
{% endblock %}

********************************************************************************

