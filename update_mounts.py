"""Rewrite docker-compose mounts based on user selections and rebuild the stack."""
# change: Provide quick context for maintainers invoking the helper manually.

from __future__ import annotations  # change: Future annotations keep type hints lightweight across Python versions.

import json  # change: Read the temporary selection file generated by the Flask app.
import os  # change: Normalise user-provided paths before injecting them into docker-compose.
import subprocess  # change: Restart docker-compose so new mounts take effect immediately.
import sys  # change: Provide a clear exit strategy and argument parsing.
from pathlib import Path  # change: Manage filesystem paths in an OS-agnostic way.
from typing import List  # change: Offer simple type hints for maintainability.

try:
    import yaml  # type: ignore  # change: PyYAML handles docker-compose parsing.
except ImportError as exc:
    print(f"[ERROR] PyYAML is required to update mounts: {exc}")
    sys.exit(1)


COMPOSE_FILE = Path('docker-compose.yml')  # change: Always operate on the root-level docker-compose file.
APP_SERVICE_KEY = 'app'  # change: Only the application container needs dynamic bind mounts.
DYNAMIC_TARGET_PREFIX = '/mnt/data'  # change: Sequential targets simplify discovery inside the container.


def normalise_directories(raw: List[str]) -> List[str]:
    """Ensure provided directories are absolute and existing."""

    normalised: List[str] = []  # change: Collect only directories that survive validation.
    for entry in raw:
        candidate = os.path.abspath(os.path.expanduser(entry))  # change: Resolve tildes and relative paths safely.
        if os.path.isdir(candidate):
            normalised.append(candidate)  # change: Keep paths that exist so docker-compose does not fail.
        else:
            print(f"[WARN] Skipping missing directory: {candidate}")  # change: Warn operators about ignored entries.
    return normalised


def load_compose() -> dict:
    """Load docker-compose.yml into a Python structure."""

    with COMPOSE_FILE.open('r', encoding='utf-8') as handle:
        return yaml.safe_load(handle)  # change: Parse YAML once to edit volumes programmatically.


def persist_compose(compose: dict) -> None:
    """Write the updated docker-compose configuration back to disk."""

    with COMPOSE_FILE.open('w', encoding='utf-8') as handle:
        yaml.safe_dump(compose, handle, sort_keys=False)  # change: Preserve key order for readability.


def update_app_volumes(compose: dict, directories: List[str]) -> None:
    """Refresh the app service volumes and append dynamic mounts."""

    services = compose.setdefault('services', {})  # change: Guarantee the services section exists.
    app_service = services.setdefault(APP_SERVICE_KEY, {})  # change: Initialise the app service map if missing.
    volumes = app_service.get('volumes', [])  # change: Start from any existing bind mounts.

    preserved = []
    for volume in volumes:
        if isinstance(volume, dict) and str(volume.get('target', '')).startswith(DYNAMIC_TARGET_PREFIX):
            continue  # change: Remove previously generated dynamic mounts before appending new ones.
        preserved.append(volume)  # change: Retain static mounts like archives and session storage.

    app_service['volumes'] = preserved  # change: Reset the volumes list so dynamic mounts rebuild from scratch.

    for index, source in enumerate(directories, start=1):
        target_path = f"{DYNAMIC_TARGET_PREFIX}{index}"
        preserved.append({  # change: Append a new bind mount that mirrors the host directory.
            'type': 'bind',
            'source': source,
            'target': target_path,
        })
        print(f"[INFO] Added bind mount: {source} -> {target_path}")  # change: Provide audit-friendly feedback.


def rebuild_stack() -> None:
    """Restart docker-compose so new mounts take effect."""

    subprocess.run(['docker', 'compose', 'down'], check=False)  # change: Allow soft shutdown even if services are already down.
    subprocess.run(['docker', 'compose', 'up', '-d', '--build'], check=True)  # change: Recreate containers with new mounts applied.


def main(config_path: str) -> None:
    """Entry point that reads the selection file and applies updates."""

    selection_path = Path(config_path)  # change: Locate the temporary JSON file generated by Flask.
    if not selection_path.exists():
        print(f"[ERROR] Mount selection file not found: {selection_path}")
        sys.exit(1)

    with selection_path.open('r', encoding='utf-8') as handle:
        directories = json.load(handle)  # change: Read the user-specified directories to mount.

    normalised = normalise_directories(directories)  # change: Strip invalid entries before touching docker-compose.
    compose = load_compose()  # change: Load the current compose configuration for mutation.
    update_app_volumes(compose, normalised)  # change: Inject the validated directories as bind mounts.
    persist_compose(compose)  # change: Write the updated compose file back to disk.

    print(f"[INFO] Mounted {len(normalised)} directories.")  # change: Summarise how many mounts were applied.
    rebuild_stack()  # change: Restart Docker so the new bind mounts become active.


if __name__ == '__main__':  # change: Allow CLI use when triggered from Flask.
    if len(sys.argv) != 2:
        print('[ERROR] Usage: update_mounts.py <path_to_selection_json>')
        sys.exit(1)
    main(sys.argv[1])
